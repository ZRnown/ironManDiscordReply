--- File: ./build.py ---
#!/usr/bin/env python3
"""
Discord Auto Reply Tool Build Script
Supports Mac and Windows platform packaging
Requirements:
- discord.py-self >= 2.0.0
- typing-extensions >= 4.0.0
- PySide6 == 6.8.0.2
- pyinstaller == 6.3.0
- shiboken6 == 6.8.0.2
"""

import os
import sys
import platform
import subprocess
from pathlib import Path


def run_command(command, description):
    """Run command and display status"""
    print(f"Running {description}...")
    try:
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
        print(f"[SUCCESS] {description} completed")
        return True
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] {description} failed: {e}")
        print(f"Error output: {e.stderr}")
        return False


def check_dependencies():
    """Check dependencies"""
    print("Checking dependencies...")

    try:
        import PyInstaller
        print(f"[OK] PyInstaller is installed ({PyInstaller.__version__})")
    except ImportError:
        print("[ERROR] PyInstaller not installed, run: pip install pyinstaller==6.3.0")
        return False

    try:
        import discord
        print(f"[OK] discord.py-self is installed ({discord.__version__})")
    except ImportError:
        print("[ERROR] discord.py-self not installed, run: pip install discord.py-self")
        return False

    try:
        import PySide6
        print(f"[OK] PySide6 is installed ({PySide6.__version__})")
    except ImportError:
        print("[ERROR] PySide6 not installed, run: pip install PySide6==6.8.0.2")
        return False

    try:
        import typing_extensions
        print("[OK] typing-extensions is installed")
    except ImportError:
        print("[ERROR] typing-extensions not installed, run: pip install typing-extensions>=4.0.0")
        return False

    return True


def clean_build():
    """Clean build files"""
    print("Cleaning build files...")

    dirs_to_clean = ["build", "dist"]
    for dir_name in dirs_to_clean:
        if os.path.exists(dir_name):
            import shutil
            shutil.rmtree(dir_name)
            print(f"[CLEAN] Removed {dir_name} directory")

    # Clean spec file cache
    spec_files = ["DiscordAutoReply.spec"]
    for spec_file in spec_files:
        if os.path.exists(spec_file):
            os.remove(spec_file)
            print(f"[CLEAN] Removed {spec_file}")


def build_app(target_platform="auto"):
    """æ„å»ºåº”ç”¨ç¨‹åº"""
    if target_platform == "auto":
        system = platform.system().lower()
    else:
        system = target_platform.lower()

    print(f"Target platform: {system}")

    # Choose spec file based on platform
    if system == "windows":
        spec_template = "DiscordAutoReply-windows.spec"
        if os.path.exists(spec_template):
            # Use Windows-specific spec file
            spec_file = spec_template
            print(f"Using Windows-specific spec file: {spec_template}")
            command_str = f"pyinstaller --clean --noconfirm {spec_file}"
            print(f"Executing command: {command_str}")
            return run_command(command_str, "building Windows application")

    # Create spec file for better module control (for macOS and other platforms)
    spec_content = '''# -*- mode: python ; coding: utf-8 -*-

import sys
import os
from PyInstaller.utils.hooks import collect_all

# Add src directory to path
sys.path.insert(0, os.path.join(SPECPATH, 'src'))

block_cipher = None

# Define the main script
main_script = os.path.join(SPECPATH, 'src', 'main.py')

# Collect PySide6 and shiboken6
pyside6_datas, pyside6_binaries, pyside6_hiddenimports = collect_all('PySide6')
shiboken6_datas, shiboken6_binaries, shiboken6_hiddenimports = collect_all('shiboken6')

# Core hidden imports
hidden_imports = [
    'discord_client',
    'config_manager',
    'gui',
    'discord.ext.commands',  # ç¡®ä¿commandsæ‰©å±•è¢«åŒ…å«
    'discord.ext.tasks',     # å¦‚æœç”¨åˆ°tasks
] + pyside6_hiddenimports + shiboken6_hiddenimports

# Data files - åªåŒ…å«å¿…è¦çš„é…ç½®æ–‡ä»¶
data_files = []
if os.path.exists('config'):
    data_files.append(('config', 'config'))

# ç§»é™¤ä¸å¿…è¦çš„assetså’Œsrcç›®å½•æ‰“åŒ…

a = Analysis(
    [main_script],
    pathex=[SPECPATH],
    binaries=pyside6_binaries + shiboken6_binaries,
    datas=data_files + pyside6_datas + shiboken6_datas,
    hiddenimports=hidden_imports,
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[
        # --- æ ‡å‡†åº“åƒåœ¾ ---
        'tkinter', 'unittest', 'pdb', 'pydoc', 'test', 'distutils', 'email.test',

        # --- å¸¸ç”¨ç§‘å­¦è®¡ç®—åº“ (å¦‚æœæœ‰æ®‹ç•™) ---
        'numpy', 'matplotlib', 'pandas', 'scipy', 'PIL', 'cv2', 'pygame',

        # --- å¼€å‘å·¥å…· ---
        'pip', 'setuptools', 'wheel',

        # --- PySide6/Qt å·¨å‹æ— ç”¨æ¨¡å— (å…³é”®å‡é‡åŒº) ---
        'PySide6.QtWebEngine',
        'PySide6.QtWebEngineCore',
        'PySide6.QtWebEngineWidgets',  # æµè§ˆå™¨å†…æ ¸ï¼Œæœ€å¤§æ¯’ç˜¤
        'PySide6.QtQml',
        'PySide6.QtQuick',
        'PySide6.QtQuickWidgets',      # QML ç›¸å…³ï¼Œç”¨çš„æ˜¯ QtWidgetsï¼Œä¸éœ€è¦è¿™ä¸ª
        'PySide6.QtSql',               # é™¤éç”¨äº† QtSqlï¼Œå¦åˆ™æ’é™¤
        'PySide6.QtTest',
        'PySide6.QtDesigner',
        'PySide6.QtHelp',
        'PySide6.QtMultimedia',
        'PySide6.QtMultimediaWidgets',
        'PySide6.QtOpenGL',            # ç®€å•çš„ GUI ä¸éœ€è¦ OpenGL
        'PySide6.QtOpenGLWidgets',
        'PySide6.QtPositioning',
        'PySide6.QtPrintSupport',
        'PySide6.QtQuick3D',
        'PySide6.QtSensors',
        'PySide6.QtSerialPort',
        'PySide6.QtSvg',               # å¦‚æœæ²¡ç”¨ SVG å›¾æ ‡å¯æ’é™¤
        'PySide6.QtSvgWidgets',
        'PySide6.QtWebChannel',
        'PySide6.QtWebSockets',
        'PySide6.Qt3DCore',
        'PySide6.Qt3DInput',
        'PySide6.Qt3DLogic',
        'PySide6.Qt3DRender',
        'PySide6.QtCharts',
        'PySide6.QtDataVisualization',
    ],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

# === æ–°å¢ï¼šæš´åŠ›è¿‡æ»¤ Qt åƒåœ¾æ–‡ä»¶ ===
def filter_qt_bloat(toc):
    """è¿‡æ»¤æ‰ä¸éœ€è¦çš„ Qt æ–‡ä»¶"""
    new_toc = []
    for dest, source, type_ in toc:
        # 1. è¿‡æ»¤ç¿»è¯‘æ–‡ä»¶ (*.qm)ï¼Œé™¤éä½ éœ€è¦å¤šè¯­è¨€
        if source and 'translations' in source and source.endswith('.qm'):
            # ä¿ç•™ä¸­æ–‡å’Œè‹±æ–‡(å¯é€‰)
            if 'zh_' not in source and 'en_' not in source:
                continue

        # 2. è¿‡æ»¤æ‰ imageformats ä¸­ä¸å¸¸ç”¨çš„æ ¼å¼
        if 'imageformats' in dest:
            # åªä¿ç•™ jpg, png, ico
            if not (dest.endswith('qjpeg.dll') or dest.endswith('qpng.dll') or dest.endswith('qico.dll')):
                continue

        # 3. å†æ¬¡ç¡®ä¿ WebEngine ç›¸å…³çš„ DLL ä¸è¢«æ‰“åŒ… (åŒé‡ä¿é™©)
        if 'Qt6WebEngine' in dest or 'Qt6Quick' in dest or 'Qt6Qml' in dest or 'Qt6OpenGL' in dest:
            continue

        new_toc.append((dest, source, type_))
    return new_toc

# åº”ç”¨è¿‡æ»¤
a.binaries = filter_qt_bloat(a.binaries)
a.datas = filter_qt_bloat(a.datas)
# ===================================

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='DiscordAutoReply',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,  # Windows ä¸Šå¿…é¡»ä¸º Falseï¼Œå¦åˆ™ DLL ä¼šæŸå
    upx=False,  # åœ¨Windowsä¸Šç¦ç”¨UPXï¼Œé¿å…DLLåŠ è½½é—®é¢˜
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)
'''

    # Write spec file
    spec_file = "DiscordAutoReply.spec"
    with open(spec_file, 'w', encoding='utf-8') as f:
        f.write(spec_content)

    # Base PyInstaller command using spec file
    cmd = [
        "pyinstaller",
        "--clean",  # Clean temporary files
        "--noconfirm",
        spec_file,  # Use spec file (spec file defines output mode)
    ]

    # Run PyInstaller
    command_str = " ".join(cmd)
    print(f"Executing command: {command_str}")

    return run_command(command_str, "building application")


def create_dmg():
    """Create DMG file for macOS"""
    if platform.system().lower() != "darwin":
        return True

    print("Creating DMG file for macOS...")

    app_path = "dist/DiscordAutoReply.app"
    dmg_path = "dist/DiscordAutoReply.dmg"

    if not os.path.exists(app_path):
        print("[ERROR] .app file not found")
        return False

    # Use hdiutil to create DMG
    cmd = f"hdiutil create -volname 'DiscordAutoReply' -srcfolder {app_path} -ov -format UDZO {dmg_path}"

    return run_command(cmd, "creating DMG file")


def main():
    """ä¸»å‡½æ•°"""
    print("Discord Auto Reply Tool Builder")
    print("=" * 50)

    # Parse command line arguments
    import argparse
    parser = argparse.ArgumentParser(description='Build Discord auto reply tool')
    parser.add_argument('--target', choices=['windows', 'mac', 'auto'],
                       default='auto', help='Target platform (default: auto-detect)')
    parser.add_argument('--no-dmg', action='store_true',
                       help='Do not create DMG file for macOS')
    args = parser.parse_args()

    # Check Python version
    if sys.version_info < (3, 8):
        print("[ERROR] Python 3.8 or higher is required")
        return False

    print(f"Python version: {sys.version}")
    print(f"Target platform: {args.target}")

    # Check dependencies
    if not check_dependencies():
        return False

    # Switch to project root directory
    project_root = Path(__file__).parent
    os.chdir(project_root)

    # Clean old build files
    clean_build()

    # Build application
    if not build_app(args.target):
        return False

    # Create DMG for macOS (if not Windows target and not disabled)
    if not args.no_dmg and platform.system().lower() == "darwin":
        if not create_dmg():
            return False

    print("\n" + "=" * 50)
    print("[SUCCESS] Build completed!")

    # Display output file information
    dist_dir = Path("dist")
    if dist_dir.exists():
        print("\nOutput files:")
        for file_path in dist_dir.iterdir():
            if file_path.is_file():
                size_mb = file_path.stat().st_size / (1024 * 1024)
                print(f"  {file_path.name}: {size_mb:.2f} MB")

    print("\nUsage instructions:")
    print("1. Run the generated executable file")
    print("2. Add Discord accounts and auto-reply rules in the program")
    print("3. Click start to begin monitoring and auto-replying")

    return True


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
-e 

--- File: ./run.py ---
#!/usr/bin/env python3
"""
Discordè‡ªåŠ¨å›å¤å·¥å…·è¿è¡Œè„šæœ¬
"""

import sys
import os
from pathlib import Path

def main():
    # 1. è·¯å¾„è®¾ç½®
    project_root = Path(__file__).parent
    src_dir = project_root / "src"
    sys.path.insert(0, str(src_dir))

    # 2. ä¾èµ–æ£€æŸ¥
    try:
        import discord
        import PySide6

        # ç§»é™¤äº†å¯¹ Intents çš„æ£€æŸ¥ï¼Œå› ä¸º discord.py-self 2.0+ å·²ç»åºŸå¼ƒäº†å®ƒ
        print(f"Discord åº“ç‰ˆæœ¬: {getattr(discord, '__version__', 'æœªçŸ¥')}")
        print("ç¯å¢ƒä¾èµ–æ£€æŸ¥é€šè¿‡ã€‚")

    except ImportError as e:
        print(f"âŒ ç¼ºå°‘ä¾èµ–: {e}")
        print("è¯·è¿è¡Œ: pip install discord.py-self PySide6 typing-extensions")
        return

    # 3. å¯åŠ¨ GUI
    try:
        from src.gui import main as gui_main
        gui_main()
    except Exception as e:
        print(f"ç¨‹åºå´©æºƒ: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()-e 

--- File: ./src/config_manager.py ---
import json
import os
from typing import List, Dict, Any
from dataclasses import asdict
from discord_client import Account, Rule, MatchType


class ConfigManager:
    def __init__(self, config_dir: str = "config"):
        self.config_dir = config_dir
        self.config_file = os.path.join(config_dir, "config.json")
        self.ensure_config_dir()

    def ensure_config_dir(self):
        """ç¡®ä¿é…ç½®ç›®å½•å­˜åœ¨"""
        if not os.path.exists(self.config_dir):
            os.makedirs(self.config_dir)

    def save_config(self, accounts: List[Account], rules: List[Rule]):
        """ä¿å­˜é…ç½®åˆ°æ–‡ä»¶"""
        config_data = {
            "accounts": [
                {
                    "token": acc.token,
                    "is_active": acc.is_active,
                    "is_valid": acc.is_valid,
                    "last_verified": acc.last_verified,
                    "user_info": acc.user_info,
                    "rule_ids": acc.rule_ids
                }
                for acc in accounts
            ],
            "rules": [
                {
                    "id": rule.id,
                    "keywords": rule.keywords,
                    "reply": rule.reply,
                    "match_type": rule.match_type.value,
                    "target_channels": rule.target_channels,
                    "delay_min": rule.delay_min,
                    "delay_max": rule.delay_max,
                    "is_active": rule.is_active,
                    "ignore_replies": getattr(rule, 'ignore_replies', False),
                    "ignore_mentions": getattr(rule, 'ignore_mentions', False),
                    "case_sensitive": getattr(rule, 'case_sensitive', False)
                }
                for rule in rules
            ]
        }

        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, ensure_ascii=False, indent=2)
            return True
        except Exception as e:
            print(f"ä¿å­˜é…ç½®å¤±è´¥: {e}")
            return False

    def load_config(self) -> tuple[List[Account], List[Rule]]:
        """ä»æ–‡ä»¶åŠ è½½é…ç½®"""
        if not os.path.exists(self.config_file):
            return [], []

        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                config_data = json.load(f)

            accounts = []
            for acc_data in config_data.get("accounts", []):
                account = Account(
                    token=acc_data["token"],
                    is_active=acc_data.get("is_active", True),
                    is_valid=acc_data.get("is_valid", False),
                    last_verified=acc_data.get("last_verified"),
                    user_info=acc_data.get("user_info"),
                    rule_ids=acc_data.get("rule_ids", [])
                )
                accounts.append(account)

            rules = []
            for rule_data in config_data.get("rules", []):
                rule = Rule(
                    id=rule_data.get("id", f"rule_{len(rules)}"),  # å¦‚æœæ²¡æœ‰idï¼Œç”Ÿæˆä¸€ä¸ª
                    keywords=rule_data["keywords"],
                    reply=rule_data["reply"],
                    match_type=MatchType(rule_data["match_type"]),
                    target_channels=rule_data["target_channels"],
                    delay_min=rule_data.get("delay_min", 2.0),
                    delay_max=rule_data.get("delay_max", 5.0),
                    is_active=rule_data.get("is_active", True),
                    ignore_replies=rule_data.get("ignore_replies", False),
                    ignore_mentions=rule_data.get("ignore_mentions", False),
                    case_sensitive=rule_data.get("case_sensitive", False)
                )
                rules.append(rule)

            return accounts, rules

        except Exception as e:
            print(f"åŠ è½½é…ç½®å¤±è´¥: {e}")
            return [], []

    def export_config(self, filepath: str, accounts: List[Account], rules: List[Rule]) -> bool:
        """å¯¼å‡ºé…ç½®åˆ°æŒ‡å®šæ–‡ä»¶"""
        try:
            config_data = {
                "accounts": [
                    {
                        "token": acc.token,
                        "alias": acc.alias,
                        "is_active": acc.is_active
                    }
                    for acc in accounts
                ],
                "rules": [
                    {
                        "keywords": rule.keywords,
                        "reply": rule.reply,
                        "match_type": rule.match_type.value,
                        "target_channels": rule.target_channels,
                        "delay_min": rule.delay_min,
                        "delay_max": rule.delay_max,
                        "is_active": rule.is_active,
                        "ignore_replies": getattr(rule, 'ignore_replies', False),
                        "ignore_mentions": getattr(rule, 'ignore_mentions', False),
                        "case_sensitive": getattr(rule, 'case_sensitive', False)
                    }
                    for rule in rules
                ]
            }

            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, ensure_ascii=False, indent=2)
            return True
        except Exception as e:
            print(f"å¯¼å‡ºé…ç½®å¤±è´¥: {e}")
            return False

    def import_config(self, filepath: str) -> tuple[List[Account], List[Rule]]:
        """ä»æŒ‡å®šæ–‡ä»¶å¯¼å…¥é…ç½®"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                config_data = json.load(f)

            accounts = []
            for acc_data in config_data.get("accounts", []):
                account = Account(
                    token=acc_data["token"],
                    is_active=acc_data.get("is_active", True),
                    is_valid=acc_data.get("is_valid", False),
                    last_verified=acc_data.get("last_verified"),
                    user_info=acc_data.get("user_info"),
                    rule_ids=acc_data.get("rule_ids", [])
                )
                accounts.append(account)

            rules = []
            for rule_data in config_data.get("rules", []):
                rule = Rule(
                    id=rule_data.get("id", f"rule_{len(rules)}"),  # å¦‚æœæ²¡æœ‰idï¼Œç”Ÿæˆä¸€ä¸ª
                    keywords=rule_data["keywords"],
                    reply=rule_data["reply"],
                    match_type=MatchType(rule_data["match_type"]),
                    target_channels=rule_data["target_channels"],
                    delay_min=rule_data.get("delay_min", 2.0),
                    delay_max=rule_data.get("delay_max", 5.0),
                    is_active=rule_data.get("is_active", True),
                    ignore_replies=rule_data.get("ignore_replies", False),
                    ignore_mentions=rule_data.get("ignore_mentions", False),
                    case_sensitive=rule_data.get("case_sensitive", False)
                )
                rules.append(rule)

            return accounts, rules

        except Exception as e:
            print(f"å¯¼å…¥é…ç½®å¤±è´¥: {e}")
            return [], []
-e 

--- File: ./src/__init__.py ---
# Discord è‡ªåŠ¨å›å¤å·¥å…·åŒ…
-e 

--- File: ./src/discord_client.py ---
import asyncio
import discord
import re
import random
import time
import logging
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

# discord.py-self ä¸éœ€è¦Intents


class MatchType(Enum):
    PARTIAL = "partial"
    EXACT = "exact"
    REGEX = "regex"


@dataclass
class Account:
    token: str
    is_active: bool = True
    is_valid: bool = False  # TokenéªŒè¯çŠ¶æ€
    last_verified: Optional[float] = None  # æœ€åéªŒè¯æ—¶é—´
    user_info: Optional[Dict] = None  # ç”¨æˆ·ä¿¡æ¯
    rule_ids: List[str] = None  # å…³è”çš„è§„åˆ™IDåˆ—è¡¨
    last_sent_time: Optional[float] = None  # æœ€åå‘é€æ¶ˆæ¯æ—¶é—´
    rate_limit_until: Optional[float] = None  # é¢‘ç‡é™åˆ¶åˆ°æœŸæ—¶é—´

    def __post_init__(self):
        if self.rule_ids is None:
            self.rule_ids = []

    @property
    def alias(self) -> str:
        """è·å–è´¦å·åˆ«åï¼ˆä½¿ç”¨ç”¨æˆ·åï¼‰"""
        if self.user_info and isinstance(self.user_info, dict):
            return f"{self.user_info.get('name', 'Unknown')}#{self.user_info.get('discriminator', '0000')}"
        return f"Token-{self.token[:8]}..."


@dataclass
class Rule:
    id: str  # è§„åˆ™å”¯ä¸€æ ‡è¯†
    keywords: List[str]
    reply: str
    match_type: MatchType
    target_channels: List[int]
    delay_min: float = 0.1
    delay_max: float = 1.0
    is_active: bool = True
    ignore_replies: bool = True  # æ˜¯å¦å¿½ç•¥å›å¤ä»–äººçš„æ¶ˆæ¯
    ignore_mentions: bool = True  # æ˜¯å¦å¿½ç•¥åŒ…å«@ä»–äººçš„æ¶ˆæ¯
    case_sensitive: bool = False  # æ˜¯å¦åŒºåˆ†å¤§å°å†™ï¼ŒFalseè¡¨ç¤ºä¸åŒºåˆ†å¤§å°å†™


class AutoReplyClient(discord.Client):
    def __init__(self, account: Account, rules: List[Rule], log_callback=None, discord_manager=None, *args, **kwargs):
        # ä¿®æ­£: discord.py-self ä¸éœ€è¦ä¹Ÿä¸æ”¯æŒ intents å‚æ•°
        # ç›´æ¥è°ƒç”¨çˆ¶ç±»æ„é€ å‡½æ•°å³å¯
        super().__init__(*args, **kwargs)

        self.account = account
        self.rules = rules
        self.is_running = False
        self.log_callback = log_callback
        self.discord_manager = discord_manager

    async def on_ready(self):
        try:
            # ç¡®ä¿self.userä¸ä¸ºNone
            if self.user is None:
                error_msg = f"[{self.account.alias}] ç”¨æˆ·ä¿¡æ¯è·å–å¤±è´¥ï¼šclient.userä¸ºNone"
                print(error_msg)
                if self.log_callback:
                    self.log_callback(error_msg)
                self.is_running = False
                return

            self.is_running = True
            username = getattr(self.user, 'name', 'Unknown')
            discriminator = getattr(self.user, 'discriminator', '0000')
            display_name = f"{username}#{discriminator}"
            message = f"[{self.account.alias}] ç™»å½•æˆåŠŸ: {display_name}"
            print(message)
            if self.log_callback:
                self.log_callback(message)

            # æ›´æ–°è´¦å·ä¿¡æ¯
            self.account.user_info = {
                'id': str(self.user.id),
                'name': username,
                'discriminator': discriminator,
                'bot': getattr(self.user, 'bot', False)
            }

        except Exception as e:
            error_msg = f"[{self.account.alias}] on_readyäº‹ä»¶é”™è¯¯: {e}"
            print(error_msg)
            if self.log_callback:
                self.log_callback(error_msg)
            self.is_running = False

    async def on_message(self, message):
        # ä¸è¦å›å¤è‡ªå·±
        if message.author.id == self.user.id:
            return

        # æ£€æŸ¥æ˜¯å¦æ˜¯è¢«å±è”½çš„ç”¨æˆ·
        try:
            # Discord.py-self å¯èƒ½æœ‰ blocked å±æ€§
            if hasattr(message.author, 'blocked') and message.author.blocked:
                return
        except:
            pass  # å¦‚æœæ— æ³•æ£€æŸ¥ï¼Œè·³è¿‡

        for rule in self.rules:
            if not rule.is_active:
                continue

            if rule.target_channels and message.channel.id not in rule.target_channels:
                continue

            if rule.ignore_replies and message.reference is not None:
                continue

            if rule.ignore_mentions and message.mentions:
                continue

            if self._check_match(message.content, rule):
                match_msg = f"[{self.account.alias}] ğŸ¯ åŒ¹é…åˆ°å…³é”®è¯ | æ¶ˆæ¯: '{message.content}' | æ¥è‡ª: {message.author.name} | é¢‘é“: #{message.channel.name}"
                reply_msg = f"[{self.account.alias}] ğŸ¤– å‡†å¤‡å›å¤: '{rule.reply}'"

                print(match_msg)
                print(reply_msg)
                if self.log_callback:
                    self.log_callback(match_msg)
                    self.log_callback(reply_msg)

                try:
                    delay = random.uniform(rule.delay_min, rule.delay_max)
                    delay_msg = f"[{self.account.alias}] â±ï¸  ç­‰å¾… {delay:.1f} ç§’..."
                    print(delay_msg)
                    if self.log_callback:
                        self.log_callback(delay_msg)

                    try:
                        async with message.channel.typing():
                            await asyncio.sleep(delay)
                    except Exception:
                        await asyncio.sleep(delay)

                    # æ£€æŸ¥æ˜¯å¦å¯ç”¨è½®æ¢æ¨¡å¼
                    if (self.discord_manager and
                        self.discord_manager.rotation_enabled and
                        rule.target_channels and
                        message.channel.id in rule.target_channels):
                        # ä½¿ç”¨è½®æ¢æ¨¡å¼
                        success = await self.discord_manager.send_rotated_reply(
                            message.channel, rule.reply, rule.keywords[0] if rule.keywords else ""
                        )
                        if success:
                            success_msg = f"[{self.account.alias}] âœ… è½®æ¢å›å¤æˆåŠŸ"
                            print(success_msg)
                            if self.log_callback:
                                self.log_callback(success_msg)
                        else:
                            error_msg = f"[{self.account.alias}] âŒ è½®æ¢å›å¤å¤±è´¥"
                            print(error_msg)
                            if self.log_callback:
                                self.log_callback(error_msg)
                    else:
                        # ä½¿ç”¨æ™®é€šå›å¤
                        await message.reply(rule.reply)
                        success_msg = f"[{self.account.alias}] âœ… å›å¤æˆåŠŸ"
                        print(success_msg)
                        if self.log_callback:
                            self.log_callback(success_msg)

                    break # åªå¤„ç†ç¬¬ä¸€ä¸ªåŒ¹é…è§„åˆ™

                except Exception as e:
                    error_msg = f"[{self.account.alias}] âŒ å›å¤å¤±è´¥: {e}"
                    print(error_msg)
                    if self.log_callback:
                        self.log_callback(error_msg)

                break

    def _check_match(self, content: str, rule: Rule) -> bool:
        """æ£€æŸ¥æ¶ˆæ¯å†…å®¹æ˜¯å¦åŒ¹é…è§„åˆ™"""
        if not content:
            return False

        if rule.match_type == MatchType.PARTIAL:
            if rule.case_sensitive:
                # åŒºåˆ†å¤§å°å†™
                return any(keyword in content for keyword in rule.keywords)
            else:
                # ä¸åŒºåˆ†å¤§å°å†™
                content_lower = content.lower()
                return any(keyword.lower() in content_lower for keyword in rule.keywords)
        elif rule.match_type == MatchType.EXACT:
            if rule.case_sensitive:
                # åŒºåˆ†å¤§å°å†™
                return content in rule.keywords
            else:
                # ä¸åŒºåˆ†å¤§å°å†™
                content_lower = content.lower()
                return content_lower in [k.lower() for k in rule.keywords]
        elif rule.match_type == MatchType.REGEX:
            flags = 0 if rule.case_sensitive else re.IGNORECASE
            return any(re.search(keyword, content, flags) for keyword in rule.keywords)

        return False

    async def start_client(self):
        try:
            self.is_running = False

            # å¯åŠ¨å®¢æˆ·ç«¯
            await self.start(self.account.token)

            # ç­‰å¾…on_readyäº‹ä»¶ï¼Œæœ€å¤šç­‰å¾…10ç§’
            try:
                await asyncio.wait_for(self.wait_for('ready', timeout=10.0), timeout=10.0)
                # å¦‚æœèƒ½åˆ°è¾¾è¿™é‡Œï¼Œè¯´æ˜on_readyå·²ç»æˆåŠŸæ‰§è¡Œï¼Œis_runningå·²ç»è¢«è®¾ç½®ä¸ºTrue
            except asyncio.TimeoutError:
                error_msg = f"[{self.account.alias}] è¿æ¥è¶…æ—¶ï¼šç­‰å¾…readyäº‹ä»¶è¶…æ—¶"
                print(error_msg)
                if self.log_callback:
                    self.log_callback(error_msg)
                self.is_running = False
                await self.close()

        except discord.LoginFailure as e:
            error_msg = f"[{self.account.alias}] ç™»å½•å¤±è´¥: Tokenæ— æ•ˆ - {e}"
            print(error_msg)
            if self.log_callback:
                self.log_callback(error_msg)
            self.is_running = False

        except Exception as e:
            import traceback
            print(f"FULL EXCEPTION TRACEBACK:")
            traceback.print_exc()
            error_msg = f"[{self.account.alias}] å¯åŠ¨å¤±è´¥: {e}"
            print(error_msg)
            if self.log_callback:
                self.log_callback(error_msg)
            self.is_running = False

    async def stop_client(self):
        """åœæ­¢å®¢æˆ·ç«¯"""
        self.is_running = False
        await self.close()


class TokenValidator:
    """Discord TokenéªŒè¯å™¨"""

    # æ³¨æ„: TokenValidator ä¸­ä½¿ç”¨äº† discord.Client() è¿›è¡ŒéªŒè¯
    # ä¹Ÿéœ€è¦ç§»é™¤ intents å‚æ•°

    @staticmethod
    async def validate_token(token: str) -> Tuple[bool, Optional[Dict], Optional[str]]:
        token = token.strip()
        if not token:
            return False, None, "Tokenä¸ºç©º"

        # 1. å…ˆå°è¯• HTTP éªŒè¯ (æ›´ç¨³)
        try:
            http_res = await TokenValidator._validate_token_http(token)
            if http_res[0] is not None:
                return http_res
        except Exception as e:
            # HTTPéªŒè¯å®Œå…¨å¤±è´¥ï¼Œç»§ç»­WebSocketéªŒè¯
            pass

        # 2. å¤‡é€‰: WebSocket éªŒè¯
        try:
            ws_res = await TokenValidator._validate_token_websocket(token)
            return ws_res
        except Exception as e:
            return False, None, "æ‰€æœ‰éªŒè¯æ–¹æ³•éƒ½å¤±è´¥ï¼Œè¯·æ£€æŸ¥Tokenå’Œç½‘ç»œè¿æ¥"

    @staticmethod
    def _detect_token_type(token: str) -> str:
        token = token.strip()
        if len(token) > 70: return "bot"
        if token.startswith("mfa.") or len(token) < 70: return "user"
        return "unknown"

    @staticmethod
    async def _validate_token_http(token: str) -> Tuple[Optional[bool], Optional[Dict], Optional[str]]:
        import aiohttp
        token = token.strip()
        if not token: return False, None, "Tokenä¸ºç©º"

        headers = {'Authorization': token, 'User-Agent': 'DiscordBot/1.0'}
        timeout = aiohttp.ClientTimeout(total=10)  # è®¾ç½®10ç§’è¶…æ—¶
        try:
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.get('https://discord.com/api/v10/users/@me', headers=headers) as resp:
                    if resp.status == 200:
                        try:
                            data = await resp.json()
                            if not data:
                                return False, None, "å“åº”æ•°æ®ä¸ºç©º"
                            user_info = {
                                'id': data.get('id'),
                                'name': data.get('username'),
                                'discriminator': data.get('discriminator', '0000'),
                                'avatar_url': f"https://cdn.discordapp.com/avatars/{data.get('id', 'unknown')}/{data.get('avatar', 'unknown')}.png" if data.get('avatar') else None,
                                'bot': data.get('bot', False),
                                'token_type': 'bot' if data.get('bot') else 'user'
                            }
                            return True, user_info, None
                        except Exception as json_error:
                            return False, None, f"è§£æå“åº”å¤±è´¥: {str(json_error)}"
                    elif resp.status == 401:
                        return False, None, "Tokenæ— æ•ˆ"
                    elif resp.status == 403:
                        return False, None, "Tokenæƒé™ä¸è¶³"
                    elif resp.status == 429:
                        return False, None, "è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•"
                    else:
                        return False, None, f"HTTP {resp.status}"
        except asyncio.TimeoutError:
            return None, None, "è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ"
        except aiohttp.ClientError as client_error:
            return None, None, f"ç½‘ç»œè¿æ¥é”™è¯¯: {str(client_error)}"
        except Exception as e:
            # é¿å…è¿”å›å¤æ‚çš„é”™è¯¯å¯¹è±¡ï¼Œåªè¿”å›å­—ç¬¦ä¸²
            error_msg = str(e)
            # å¦‚æœé”™è¯¯ä¿¡æ¯å¤ªé•¿æˆ–åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼Œç®€åŒ–å®ƒ
            if len(error_msg) > 100 or "'" in error_msg or '"' in error_msg:
                return None, None, "éªŒè¯è¯·æ±‚å¤±è´¥"
            return None, None, error_msg

    @staticmethod
    async def _validate_token_websocket(token: str) -> Tuple[bool, Optional[Dict], Optional[str]]:
        """
        ä½¿ç”¨WebSocketéªŒè¯Tokenï¼ˆå¤‡é€‰æ–¹æ¡ˆï¼‰
        """
        client = None
        try:
            # åˆ›å»ºä¸´æ—¶å®¢æˆ·ç«¯è¿›è¡ŒéªŒè¯
            client = discord.Client()

            user_info = None
            error = None

            @client.event
            async def on_ready():
                nonlocal user_info
                try:
                    u = client.user
                    user_info = {
                        'id': str(u.id),
                        'name': u.name,
                        'discriminator': getattr(u, 'discriminator', '0000'),
                        'avatar_url': str(u.avatar.url) if u.avatar else None,
                        'bot': getattr(u, 'bot', False)
                    }
                except Exception as e:
                    pass
                await client.close()

            # å¯åŠ¨å®¢æˆ·ç«¯å¹¶è®¾ç½®è¶…æ—¶
            try:
                await asyncio.wait_for(client.start(token), timeout=15.0)  # 15ç§’è¶…æ—¶
            except asyncio.TimeoutError:
                return False, None, "WebSocketè¿æ¥è¶…æ—¶"

            # ç­‰å¾…readyäº‹ä»¶ï¼Œæœ€å¤šç­‰å¾…10ç§’
            try:
                await asyncio.wait_for(client.wait_for('ready', timeout=10.0), timeout=10.0)
            except asyncio.TimeoutError:
                return False, None, "ç­‰å¾…readyäº‹ä»¶è¶…æ—¶"

            if user_info:
                return True, user_info, None
            return False, None, "æ— æ³•è·å–ç”¨æˆ·ä¿¡æ¯"

        except asyncio.TimeoutError:
            return False, None, "WebSocketè¿æ¥è¶…æ—¶"
        except discord.LoginFailure:
            return False, None, "Tokenç™»å½•å¤±è´¥"
        except Exception as e:
            error_msg = str(e)
            # ç®€åŒ–é”™è¯¯ä¿¡æ¯ï¼Œé¿å…è¿”å›å¤æ‚çš„å†…éƒ¨é”™è¯¯
            if len(error_msg) > 50 or "sequence" in error_msg or "NoneType" in error_msg:
                return False, None, "WebSocketéªŒè¯å¤±è´¥"
            return False, None, f"éªŒè¯å¤±è´¥: {error_msg}"
        finally:
            if client and not client.is_closed():
                await client.close()


class DiscordManager:
    def __init__(self, log_callback=None):
        self.clients: List[AutoReplyClient] = []
        self.accounts: List[Account] = []
        self.rules: List[Rule] = []
        self.is_running = False
        self.validator = TokenValidator()
        self.log_callback = log_callback

        # è½®æ¢è®¾ç½®
        self.rotation_enabled: bool = False  # æ˜¯å¦å¯ç”¨è´¦å·è½®æ¢
        self.rotation_interval: int = 600  # è½®æ¢é—´éš”ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤10åˆ†é’Ÿ
        self.current_rotation_index: int = 0  # å½“å‰ä½¿ç”¨çš„è´¦å·ç´¢å¼•

    async def add_account_async(self, token: str) -> Tuple[bool, Optional[str]]:
        if any(acc.token == token for acc in self.accounts):
            return False, "Tokenå·²å­˜åœ¨"

        is_valid, user_info, msg = await self.validator.validate_token(token)

        # å³ä½¿éªŒè¯å¤±è´¥ä¹Ÿå…è®¸æ·»åŠ  (å¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜)ï¼Œä½†åœ¨UIæ˜¾ç¤ºæ— æ•ˆ
        account = Account(
            token=token,
            is_active=True,
            is_valid=is_valid or False,
            last_verified=time.time(),
            user_info=user_info
        )

        self.accounts.append(account)

        return True, "è´¦å·æ·»åŠ æˆåŠŸ" + (f" ({user_info.get('name', 'Unknown')})" if user_info and isinstance(user_info, dict) else "")


    def remove_account(self, token: str):
        """ç§»é™¤è´¦å·"""
        self.accounts = [acc for acc in self.accounts if acc.token != token]

    def add_rule(self, keywords: List[str], reply: str, match_type: MatchType,
                 target_channels: List[int], delay_min: float = 0.1, delay_max: float = 1.0,
                 ignore_replies: bool = True, ignore_mentions: bool = True,
                 case_sensitive: bool = False):
        """æ·»åŠ è§„åˆ™"""
        # ç”Ÿæˆå”¯ä¸€çš„è§„åˆ™ID
        import time
        rule_id = f"rule_{int(time.time() * 1000)}_{len(self.rules)}"

        rule = Rule(
            id=rule_id,
            keywords=keywords,
            reply=reply,
            match_type=match_type,
            target_channels=target_channels,
            delay_min=delay_min,
            delay_max=delay_max,
            ignore_replies=ignore_replies,
            ignore_mentions=ignore_mentions,
            case_sensitive=case_sensitive
        )
        self.rules.append(rule)

    def remove_rule(self, index: int):
        """ç§»é™¤è§„åˆ™"""
        if 0 <= index < len(self.rules):
            self.rules.pop(index)

    def update_rule(self, index: int, **kwargs):
        """æ›´æ–°è§„åˆ™"""
        if 0 <= index < len(self.rules):
            rule = self.rules[index]
            for key, value in kwargs.items():
                if hasattr(rule, key):
                    setattr(rule, key, value)

    async def start_all_clients(self):
        if self.is_running: return

        self.is_running = True

        await self.stop_all_clients()
        self.clients.clear()

        for acc in self.accounts:
            if acc.is_active and acc.is_valid:
                rules = [r for r in self.rules if r.id in acc.rule_ids]
                client = AutoReplyClient(acc, rules, self.log_callback, self)
                self.clients.append(client)
                # åˆ›å»ºå¯åŠ¨ä»»åŠ¡ï¼Œè®©å®ƒä»¬åœ¨åå°è¿è¡Œ
                asyncio.create_task(client.start_client())

        # ä¸åœ¨è¿™é‡Œæ£€æŸ¥çŠ¶æ€ï¼Œè®©è°ƒç”¨è€…è´Ÿè´£ç­‰å¾…å’ŒçŠ¶æ€æ£€æŸ¥

    async def stop_all_clients(self):
        self.is_running = False

        for c in self.clients:
            await c.stop_client()

        self.clients.clear()

    async def revalidate_all_accounts(self) -> List[Dict]:
        """é‡æ–°éªŒè¯æ‰€æœ‰è´¦å·çš„Token"""
        results = []

        for account in self.accounts:
            is_valid, user_info, error_msg = await self.validator.validate_token(account.token)

            # æ›´æ–°è´¦å·çŠ¶æ€
            account.is_valid = is_valid
            account.last_verified = time.time()
            account.user_info = user_info

            results.append({
                'alias': account.alias,
                'is_valid': is_valid,
                'user_info': user_info,
                'error_msg': error_msg
            })

        return results

    def get_next_available_account(self) -> Optional[Account]:
        """è·å–ä¸‹ä¸€ä¸ªå¯ç”¨çš„è´¦å·ï¼ˆç”¨äºè½®æ¢ï¼‰"""
        if not self.rotation_enabled or not self.accounts:
            return None

        # æŸ¥æ‰¾æ‰€æœ‰æœ‰æ•ˆçš„æ´»è·ƒè´¦å·
        available_accounts = [acc for acc in self.accounts if acc.is_active and acc.is_valid]

        if not available_accounts:
            return None

        # æ£€æŸ¥å½“å‰è´¦å·æ˜¯å¦å¯ä»¥å‘é€
        current_time = time.time()
        current_account = available_accounts[self.current_rotation_index % len(available_accounts)]

        # å¦‚æœå½“å‰è´¦å·æ²¡æœ‰é¢‘ç‡é™åˆ¶æˆ–é™åˆ¶å·²è¿‡æœŸï¼Œå¯ä»¥ä½¿ç”¨
        if (current_account.rate_limit_until is None or
            current_time >= current_account.rate_limit_until):
            return current_account

        # å¦åˆ™ï¼Œå¯»æ‰¾ä¸‹ä¸€ä¸ªå¯ç”¨çš„è´¦å·
        for i in range(1, len(available_accounts)):
            next_index = (self.current_rotation_index + i) % len(available_accounts)
            account = available_accounts[next_index]
            if (account.rate_limit_until is None or
                current_time >= account.rate_limit_until):
                self.current_rotation_index = next_index
                return account

        # å¦‚æœæ‰€æœ‰è´¦å·éƒ½è¢«é™åˆ¶ï¼Œè¿”å›None
        return None

    async def send_rotated_reply(self, channel, reply_text: str, rule_name: str = "") -> bool:
        """ä½¿ç”¨è½®æ¢è´¦å·å‘é€å›å¤"""
        if not self.rotation_enabled:
            return False

        account = self.get_next_available_account()
        if not account:
            if self.log_callback:
                self.log_callback(f"âŒ æ‰€æœ‰è´¦å·éƒ½è¢«é¢‘ç‡é™åˆ¶ï¼Œæ— æ³•å‘é€å›å¤")
            return False

        # æŸ¥æ‰¾å¯¹åº”çš„å®¢æˆ·ç«¯
        client = next((c for c in self.clients if c.account.token == account.token), None)
        if not client:
            if self.log_callback:
                self.log_callback(f"âŒ æ‰¾ä¸åˆ°è´¦å· {account.alias} çš„å®¢æˆ·ç«¯")
            return False

        try:
            # æ›´æ–°è´¦å·çš„æœ€åå‘é€æ—¶é—´
            current_time = time.time()
            account.last_sent_time = current_time

            # å‘é€æ¶ˆæ¯
            await channel.send(reply_text)

            # ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªè´¦å·
            available_accounts = [acc for acc in self.accounts if acc.is_active and acc.is_valid]
            if available_accounts:
                self.current_rotation_index = (self.current_rotation_index + 1) % len(available_accounts)

            if self.log_callback:
                self.log_callback(f"âœ… [{account.alias}] è½®æ¢å›å¤æˆåŠŸ: '{reply_text[:50]}...'")

            return True

        except discord.HTTPException as e:
            # æ£€æŸ¥æ˜¯å¦æ˜¯é¢‘ç‡é™åˆ¶é”™è¯¯
            if e.code == 20016:  # æ…¢é€Ÿæ¨¡å¼
                account.rate_limit_until = current_time + 600  # 10åˆ†é’Ÿé™åˆ¶
                if self.log_callback:
                    self.log_callback(f"âš ï¸ [{account.alias}] è§¦å‘æ…¢é€Ÿæ¨¡å¼ï¼Œ10åˆ†é’Ÿå†…æ— æ³•å‘é€")
            elif e.code == 50035:  # æ— æ•ˆè¡¨å•å†…å®¹
                if self.log_callback:
                    self.log_callback(f"âŒ [{account.alias}] å‘é€å¤±è´¥: æ— æ•ˆå†…å®¹")
            else:
                if self.log_callback:
                    self.log_callback(f"âŒ [{account.alias}] å‘é€å¤±è´¥: HTTP {e.code}")

            # å°è¯•ä¸‹ä¸€ä¸ªè´¦å·
            return await self.send_rotated_reply(channel, reply_text, rule_name)

        except Exception as e:
            if self.log_callback:
                self.log_callback(f"âŒ [{account.alias}] å‘é€å¼‚å¸¸: {str(e)}")
            return False

    async def revalidate_account(self, token: str) -> Tuple[bool, Optional[str]]:
        """é‡æ–°éªŒè¯æŒ‡å®šè´¦å·çš„Token"""
        account = next((acc for acc in self.accounts if acc.token == token), None)
        if not account:
            return False, "è´¦å·ä¸å­˜åœ¨"

        is_valid, user_info, error_msg = await self.validator.validate_token(account.token)

        # æ›´æ–°è´¦å·çŠ¶æ€
        account.is_valid = is_valid
        account.last_verified = time.time()
        account.user_info = user_info

        if is_valid and user_info and isinstance(user_info, dict):
            username = f"{user_info.get('name', 'Unknown')}#{user_info.get('discriminator', '0000')}"
            return True, f"éªŒè¯æˆåŠŸï¼Œç”¨æˆ·å: {username}"
        else:
            return False, f"éªŒè¯å¤±è´¥: {error_msg}"

    def get_status(self) -> Dict:
        """è·å–å½“å‰çŠ¶æ€"""
        return {
            "is_running": self.is_running,
            "accounts": [
                {
                    "token": acc.token,
                    "alias": acc.alias,  # ç°åœ¨æ˜¯åªè¯»å±æ€§
                    "is_active": acc.is_active,
                    "is_running": any(c.account.token == acc.token and c.is_running for c in self.clients)
                }
                for acc in self.accounts
            ],
            "rules_count": len(self.rules),
            "active_rules": len([r for r in self.rules if r.is_active])
        }
-e 

--- File: ./src/main.py ---
#!/usr/bin/env python3
"""
Discord è‡ªåŠ¨å›å¤å·¥å…·
æ”¯æŒå¤šè´¦å·ã€å¤šè§„åˆ™çš„Discordè‡ªåŠ¨å›å¤æ¡Œé¢åº”ç”¨
"""

import sys
import os

# æ·»åŠ srcç›®å½•åˆ°Pythonè·¯å¾„
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from gui import main
except ImportError:
    # å¦‚æœç›¸å¯¹å¯¼å…¥å¤±è´¥ï¼Œå°è¯•ç»å¯¹å¯¼å…¥
    import gui
    main = gui.main

if __name__ == "__main__":
    # ç›´æ¥è°ƒç”¨ main()ï¼Œå› ä¸º gui.main() æ˜¯åŒæ­¥çš„ (app.exec())
    # ä¸è¦ä½¿ç”¨ asyncio.run()ï¼Œå› ä¸º PySide6 çš„äº‹ä»¶å¾ªç¯æ¥ç®¡äº†ä¸»çº¿ç¨‹
    main()
-e 

--- File: ./src/gui.py ---
import sys
import asyncio
from typing import List, Optional
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTabWidget, QListWidget, QListWidgetItem, QPushButton, QLabel,
    QLineEdit, QTextEdit, QComboBox, QSpinBox, QDoubleSpinBox,
    QCheckBox, QGroupBox, QTableWidget, QTableWidgetItem,
    QHeaderView, QMessageBox, QFileDialog, QSplitter, QProgressBar,
    QDialog, QMenu, QScrollArea
)
from PySide6.QtCore import Qt, QThread, Signal, QTimer
from PySide6.QtGui import QFont, QIcon, QColor

from discord_client import DiscordManager, Account, Rule, MatchType
from config_manager import ConfigManager


class AccountDialog(QDialog):
    """è´¦å·æ·»åŠ /ç¼–è¾‘å¯¹è¯æ¡†"""
    def __init__(self, parent=None, account=None, discord_manager=None):
        super().__init__(parent)
        self.account = account
        self.discord_manager = discord_manager
        self.is_validating = False
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle("æ·»åŠ è´¦å·" if not self.account else "ç¼–è¾‘è´¦å·")
        self.setModal(True)
        self.resize(500, 250)

        layout = QVBoxLayout(self)

        # Tokenè¾“å…¥
        token_layout = QHBoxLayout()
        token_layout.addWidget(QLabel("Discord Token:"))
        self.token_input = QLineEdit()
        self.token_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.token_input.setPlaceholderText("è¾“å…¥Discordç”¨æˆ·Tokenï¼ˆéæœºå™¨äººTokenï¼‰")
        if self.account:
            self.token_input.setText(self.account.token)
        self.token_input.textChanged.connect(self.on_token_changed)
        token_layout.addWidget(self.token_input)

        # éªŒè¯æŒ‰é’®
        self.validate_btn = QPushButton("éªŒè¯Token")
        self.validate_btn.clicked.connect(self.validate_token)
        token_layout.addWidget(self.validate_btn)

        # å¸®åŠ©æŒ‰é’®
        help_btn = QPushButton("â“")
        help_btn.setMaximumWidth(30)
        help_btn.setToolTip("å¦‚ä½•è·å–Discord Token")
        help_btn.clicked.connect(self.show_token_help)
        token_layout.addWidget(help_btn)

        layout.addLayout(token_layout)

        # éªŒè¯çŠ¶æ€æ˜¾ç¤º
        self.status_label = QLabel("")
        self.status_label.setStyleSheet("color: gray; font-style: italic;")
        self.status_label.setWordWrap(True)  # å…è®¸æ¢è¡Œ
        layout.addWidget(self.status_label)

        # æ˜¾ç¤ºå½“å‰ç”¨æˆ·ä¿¡æ¯ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
        if self.account and self.account.user_info and isinstance(self.account.user_info, dict):
            user_info = self.account.user_info
            username = f"{user_info.get('name', 'Unknown')}#{user_info.get('discriminator', '0000')}"
            info_label = QLabel(f"å½“å‰è´¦å·: {username}")
            info_label.setStyleSheet("color: blue; font-weight: bold;")
            layout.addWidget(info_label)

        # æ¿€æ´»çŠ¶æ€
        self.active_checkbox = QCheckBox("å¯ç”¨è´¦å·")
        self.active_checkbox.setChecked(True if not self.account else self.account.is_active)
        layout.addWidget(self.active_checkbox)

        # æŒ‰é’®
        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()

        cancel_btn = QPushButton("å–æ¶ˆ")
        cancel_btn.clicked.connect(self.reject)
        buttons_layout.addWidget(cancel_btn)

        self.ok_btn = QPushButton("ç¡®å®š")
        self.ok_btn.clicked.connect(self.accept_and_validate)
        self.ok_btn.setDefault(True)
        buttons_layout.addWidget(self.ok_btn)

        layout.addLayout(buttons_layout)

        # å¦‚æœæ˜¯ç¼–è¾‘æ¨¡å¼ï¼Œæ˜¾ç¤ºå½“å‰éªŒè¯çŠ¶æ€
        if self.account:
            self.update_validation_status()

    def on_token_changed(self):
        """Tokenè¾“å…¥æ”¹å˜æ—¶é‡ç½®éªŒè¯çŠ¶æ€"""
        if not self.is_validating:
            self.status_label.setText("")
            self.status_label.setStyleSheet("color: gray; font-style: italic;")

    def update_validation_status(self):
        """æ›´æ–°éªŒè¯çŠ¶æ€æ˜¾ç¤º"""
        if self.account and self.account.last_verified:
            if self.account.is_valid and self.account.user_info and isinstance(self.account.user_info, dict):
                user_info = self.account.user_info
                username = f"{user_info.get('name', 'Unknown')}#{user_info.get('discriminator', '0000')}"
                self.status_label.setText(f"âœ… Tokenæœ‰æ•ˆ - ç”¨æˆ·å: {username}")
                self.status_label.setStyleSheet("color: green;")
            else:
                self.status_label.setText("âŒ Tokenæ— æ•ˆæˆ–å·²è¿‡æœŸ")
                self.status_label.setStyleSheet("color: red;")
        else:
            self.status_label.setText("âš ï¸ TokenæœªéªŒè¯")
            self.status_label.setStyleSheet("color: orange;")

    async def validate_token_async(self):
        """å¼‚æ­¥éªŒè¯Token"""
        token = self.token_input.text().strip()
        if not token:
            self.status_label.setText("âŒ è¯·è¾“å…¥Token")
            self.status_label.setStyleSheet("color: red;")
            return

        self.is_validating = True
        self.validate_btn.setEnabled(False)
        self.validate_btn.setText("éªŒè¯ä¸­...")
        self.status_label.setText("ğŸ”„ æ­£åœ¨éªŒè¯Tokenï¼Œè¯·ç¨å€™...")
        self.status_label.setStyleSheet("color: blue;")

        # å¼ºåˆ¶æ›´æ–°UI
        QApplication.processEvents()

        try:
            # æ›´æ–°çŠ¶æ€ï¼šæ­£åœ¨è¿æ¥
            self.status_label.setText("ğŸ”— æ­£åœ¨è¿æ¥DiscordæœåŠ¡å™¨...")
            self.status_label.setStyleSheet("color: blue;")
            QApplication.processEvents()

            # å¯¼å…¥éªŒè¯å™¨
            from discord_client import TokenValidator
            validator = TokenValidator()

            # æ‰§è¡ŒéªŒè¯
            is_valid, user_info, error_msg = await validator.validate_token(token)

            if is_valid and user_info and isinstance(user_info, dict):
                username = f"{user_info.get('name', 'Unknown')}#{user_info.get('discriminator', '0000')}"
                bot_status = "ğŸ¤– æœºå™¨äººè´¦å·" if user_info.get('bot', False) else "ğŸ‘¤ ç”¨æˆ·è´¦å·"
                self.status_label.setText(f"âœ… Tokenæœ‰æ•ˆ\n{bot_status}\nğŸ‘¤ ç”¨æˆ·å: {username}\nğŸ”— éªŒè¯æˆåŠŸï¼")
                self.status_label.setStyleSheet("color: green;")
            else:
                # æä¾›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
                if "401" in error_msg or "Unauthorized" in error_msg:
                    friendly_msg = "Tokenæ— æ•ˆæˆ–å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–"
                elif "Improper token" in error_msg:
                    friendly_msg = "Tokenæ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ˜¯å¦æ­£ç¡®å¤åˆ¶"
                elif "429" in error_msg:
                    friendly_msg = "è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•"
                elif "403" in error_msg:
                    friendly_msg = "Tokenæƒé™ä¸è¶³"
                elif "timeout" in error_msg.lower():
                    friendly_msg = "è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ"
                elif "æ ¼å¼" in error_msg:
                    friendly_msg = error_msg
                else:
                    friendly_msg = "TokenéªŒè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥Tokenæ˜¯å¦æ­£ç¡®"

                self.status_label.setText(f"âŒ Tokenæ— æ•ˆ\nğŸ’¡ {friendly_msg}\nğŸ” åŸå§‹é”™è¯¯: {error_msg}")
                self.status_label.setStyleSheet("color: red;")

        except Exception as e:
            self.status_label.setText(f"âŒ éªŒè¯å‡ºé”™: {str(e)}")
            self.status_label.setStyleSheet("color: red;")
        finally:
            self.is_validating = False
            self.validate_btn.setEnabled(True)
            self.validate_btn.setText("éªŒè¯Token")

    def validate_token(self):
        """éªŒè¯Tokenï¼ˆåŒæ­¥åŒ…è£…å™¨ï¼‰"""
        # åˆ›å»ºæ–°çš„äº‹ä»¶å¾ªç¯æ¥è¿è¡Œå¼‚æ­¥éªŒè¯
        # æ³¨æ„ï¼šè¿™ä¼šæš‚æ—¶é˜»å¡GUIï¼Œä½†åœ¨PySide6ä¸ä½¿ç”¨qasyncçš„æƒ…å†µä¸‹ï¼Œè¿™æ˜¯å¤„ç†çŸ­æ—¶é—´å¼‚æ­¥ä»»åŠ¡çš„ç®€å•æ–¹æ³•
        try:
            # æ˜¾ç¤ºéªŒè¯å¼€å§‹çŠ¶æ€
            self.status_label.setText("ğŸ”„ æ­£åœ¨éªŒè¯Tokenï¼Œè¯·ç¨å€™...")
            self.status_label.setStyleSheet("color: blue;")
            QApplication.processEvents()  # å¼ºåˆ¶æ›´æ–°UI

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(self.validate_token_async())
            loop.close()
        except Exception as e:
            error_msg = str(e)
            if len(error_msg) > 100:
                error_msg = error_msg[:100] + "..."
            self.status_label.setText(f"âŒ éªŒè¯ç³»ç»Ÿé”™è¯¯: {error_msg}")
            self.status_label.setStyleSheet("color: red;")

    def show_token_help(self):
        """æ˜¾ç¤ºTokenè·å–å¸®åŠ©"""
        help_text = """
        <h3>å¦‚ä½•è·å–Discord Token</h3>

        <p><b>é‡è¦æé†’ï¼š</b>è¯·è°¨æ…ä½¿ç”¨Tokenï¼Œä¸è¦æ³„éœ²ç»™ä»–äººï¼</p>

        <h4>è·å–ç”¨æˆ·Tokenï¼ˆæ¨èç”¨äºä¸ªäººä½¿ç”¨ï¼‰ï¼š</h4>
        <ol>
        <li>æ‰“å¼€Discordç½‘é¡µç‰ˆæˆ–æ¡Œé¢å®¢æˆ·ç«¯</li>
        <li>æŒ‰ <b>F12</b> æ‰“å¼€å¼€å‘è€…å·¥å…·</li>
        <li>åˆ‡æ¢åˆ° <b>Application</b> æ ‡ç­¾é¡µ</li>
        <li>åœ¨å·¦ä¾§é€‰æ‹© <b>Local Storage</b> â†’ <b>https://discord.com</b></li>
        <li>æ‰¾åˆ° <b>token</b> å­—æ®µ</li>
        <li>å¤åˆ¶ <b>value</b> åˆ—çš„å€¼ï¼ˆä¸åŒ…å«å¼•å·ï¼‰</li>
        </ol>

        <h4>Tokenæ ¼å¼ç¤ºä¾‹ï¼š</h4>
        <p><code>mfa.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</code></p>
        <p>æˆ–</p>
        <p><code>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</code></p>

        <h4>å¸¸è§é”™è¯¯ï¼š</h4>
        <ul>
        <li><b>401 Unauthorized</b>: Tokenæ— æ•ˆæˆ–å·²è¿‡æœŸ</li>
        <li><b>Improper token</b>: Tokenæ ¼å¼é”™è¯¯</li>
        <li><b>403 Forbidden</b>: Tokenæƒé™ä¸è¶³</li>
        </ul>

        <p><b>æ³¨æ„ï¼š</b>Tokenä¼šå®šæœŸè¿‡æœŸï¼Œå»ºè®®å®šæœŸæ›´æ–°ã€‚</p>
        """

        QMessageBox.information(self, "Discord Tokenè·å–æŒ‡å—",
                               help_text, QMessageBox.StandardButton.Ok)

    def accept_and_validate(self):
        """ç¡®å®šå¹¶éªŒè¯"""
        # å¦‚æœè¿˜æ²¡æœ‰éªŒè¯è¿‡ï¼Œè‡ªåŠ¨éªŒè¯ä¸€æ¬¡
        if not self.status_label.text() or "æœªéªŒè¯" in self.status_label.text():
            self.validate_token()

        # æ£€æŸ¥éªŒè¯ç»“æœ
        if "âŒ" in self.status_label.text():
            reply = QMessageBox.question(
                self, "Tokenæ— æ•ˆ",
                "TokenéªŒè¯å¤±è´¥ï¼Œç¡®å®šè¦ç»§ç»­ä¿å­˜å—ï¼Ÿ",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return

        self.accept()

    def get_account_data(self):
        """è·å–è´¦å·æ•°æ®"""
        # è§£æéªŒè¯çŠ¶æ€
        is_valid = "âœ…" in self.status_label.text()
        # æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ä¸èƒ½è½»æ˜“ä»labelæ–‡æœ¬é‡å»ºuser_infoï¼Œ
        # å®é™…ä½¿ç”¨æ—¶ä¼šé‡æ–°éªŒè¯æˆ–ä¿ç•™åŸæœ‰info
        user_info = self.account.user_info if self.account else None

        # å¦‚æœåˆšæ‰éªŒè¯æˆåŠŸäº†ï¼Œä½†æ˜¯self.account.user_infoå¯èƒ½æ²¡æ›´æ–°ï¼ˆå› ä¸ºvalidateåªè·‘äº†ä¸€æ¬¡é€»è¾‘ï¼‰
        # åœ¨è¿™é‡Œæˆ‘ä»¬ç®€åŒ–å¤„ç†ï¼šå¦‚æœéœ€è¦æœ€æ–°user_infoï¼Œä¾èµ–å¤–éƒ¨é‡æ–°éªŒè¯

        return {
            'token': self.token_input.text().strip(),
            'is_active': self.active_checkbox.isChecked(),
            'is_valid': is_valid,
            'user_info': user_info
        }


class RuleDialog(QDialog):
    """è§„åˆ™æ·»åŠ /ç¼–è¾‘å¯¹è¯æ¡†"""
    def __init__(self, parent=None, rule=None):
        super().__init__(parent)
        self.rule = rule
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle("æ·»åŠ è§„åˆ™" if not self.rule else "ç¼–è¾‘è§„åˆ™")
        self.setModal(True)
        self.resize(500, 350)

        layout = QVBoxLayout(self)

        # å…³é”®è¯è¾“å…¥
        keywords_layout = QHBoxLayout()
        keywords_layout.addWidget(QLabel("å…³é”®è¯:"))
        self.keywords_input = QLineEdit()
        self.keywords_input.setPlaceholderText("ç”¨é€—å·åˆ†éš”å¤šä¸ªå…³é”®è¯")
        if self.rule:
            self.keywords_input.setText(", ".join(self.rule.keywords))
        keywords_layout.addWidget(self.keywords_input)
        layout.addLayout(keywords_layout)

        # å›å¤å†…å®¹
        reply_layout = QVBoxLayout()
        reply_layout.addWidget(QLabel("å›å¤å†…å®¹:"))
        self.reply_input = QTextEdit()
        self.reply_input.setMaximumHeight(80)
        if self.rule:
            self.reply_input.setText(self.rule.reply)
        reply_layout.addWidget(self.reply_input)
        layout.addLayout(reply_layout)

        # åŒ¹é…ç±»å‹å’Œé¢‘é“ID
        type_channel_layout = QHBoxLayout()

        # åŒ¹é…ç±»å‹
        type_layout = QVBoxLayout()
        type_layout.addWidget(QLabel("åŒ¹é…ç±»å‹:"))
        self.match_type_combo = QComboBox()
        self.match_type_combo.addItems(["partial - éƒ¨åˆ†åŒ¹é…", "exact - ç²¾ç¡®åŒ¹é…", "regex - æ­£åˆ™è¡¨è¾¾å¼"])
        if self.rule:
            if self.rule.match_type.value == "partial":
                self.match_type_combo.setCurrentIndex(0)
            elif self.rule.match_type.value == "exact":
                self.match_type_combo.setCurrentIndex(1)
            else:
                self.match_type_combo.setCurrentIndex(2)
        type_layout.addWidget(self.match_type_combo)
        type_channel_layout.addLayout(type_layout)

        # ç›®æ ‡é¢‘é“
        channel_layout = QVBoxLayout()
        channel_layout.addWidget(QLabel("é¢‘é“ID (å¯é€‰):"))
        self.channels_input = QLineEdit()
        self.channels_input.setPlaceholderText("ä¸ºç©ºåˆ™ç›‘å¬æ‰€æœ‰é¢‘é“")
        if self.rule:
            self.channels_input.setText(", ".join(map(str, self.rule.target_channels)))
        channel_layout.addWidget(self.channels_input)
        type_channel_layout.addLayout(channel_layout)

        layout.addLayout(type_channel_layout)

        # å»¶è¿Ÿè®¾ç½®
        delay_layout = QHBoxLayout()
        delay_layout.addWidget(QLabel("å›å¤å»¶è¿Ÿ:"))
        self.delay_min_spin = QDoubleSpinBox()
        self.delay_min_spin.setRange(0.1, 30.0)
        self.delay_min_spin.setValue(0.1 if not self.rule else self.rule.delay_min)
        self.delay_min_spin.setSuffix("ç§’")
        delay_layout.addWidget(self.delay_min_spin)

        delay_layout.addWidget(QLabel("-"))

        self.delay_max_spin = QDoubleSpinBox()
        self.delay_max_spin.setRange(0.1, 30.0)
        self.delay_max_spin.setValue(1.0 if not self.rule else self.rule.delay_max)
        self.delay_max_spin.setSuffix("ç§’")
        delay_layout.addWidget(self.delay_max_spin)

        layout.addLayout(delay_layout)

        # æ¿€æ´»çŠ¶æ€
        self.active_checkbox = QCheckBox("å¯ç”¨è§„åˆ™")
        self.active_checkbox.setChecked(True if not self.rule else self.rule.is_active)
        layout.addWidget(self.active_checkbox)

        # å¿½ç•¥å›å¤æ¶ˆæ¯
        self.ignore_replies_checkbox = QCheckBox("å¿½ç•¥å›å¤æ¶ˆæ¯")
        self.ignore_replies_checkbox.setToolTip("å¯ç”¨åï¼Œå½“æœ‰äººå›å¤åˆ«äººçš„æ¶ˆæ¯æ—¶ï¼Œä¸ä¼šå†å›å¤è¿™æ¡å›å¤æ¶ˆæ¯")
        self.ignore_replies_checkbox.setChecked(True if not self.rule else getattr(self.rule, 'ignore_replies', False))
        layout.addWidget(self.ignore_replies_checkbox)

        # å¿½ç•¥@æ¶ˆæ¯
        self.ignore_mentions_checkbox = QCheckBox("å¿½ç•¥@æ¶ˆæ¯")
        self.ignore_mentions_checkbox.setToolTip("å¯ç”¨åï¼Œå½“æ¶ˆæ¯ä¸­åŒ…å«@ä»–äººæ—¶ï¼Œä¸ä¼šå›å¤è¿™æ¡æ¶ˆæ¯")
        self.ignore_mentions_checkbox.setChecked(True if not self.rule else getattr(self.rule, 'ignore_mentions', False))

        # å¤§å°å†™æ•æ„Ÿ
        self.case_sensitive_checkbox = QCheckBox("ä¸åŒºåˆ†å¤§å°å†™")
        self.case_sensitive_checkbox.setToolTip("å¯ç”¨åï¼Œå…³é”®è¯åŒ¹é…å°†ä¸åŒºåˆ†å¤§å°å†™ï¼›å…³é—­åï¼Œå°†åŒºåˆ†å¤§å°å†™")
        self.case_sensitive_checkbox.setChecked(True if not self.rule else not getattr(self.rule, 'case_sensitive', False))
        layout.addWidget(self.case_sensitive_checkbox)
        layout.addWidget(self.ignore_mentions_checkbox)

        # æŒ‰é’®
        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()

        cancel_btn = QPushButton("å–æ¶ˆ")
        cancel_btn.clicked.connect(self.reject)
        buttons_layout.addWidget(cancel_btn)

        self.ok_btn = QPushButton("ç¡®å®š")
        self.ok_btn.clicked.connect(self.accept)
        self.ok_btn.setDefault(True)
        buttons_layout.addWidget(self.ok_btn)

        layout.addLayout(buttons_layout)

    def get_rule_data(self):
        """è·å–è§„åˆ™æ•°æ®"""
        match_type_map = {
            0: "partial",
            1: "exact",
            2: "regex"
        }

        # è§£æé¢‘é“ID
        channels_text = self.channels_input.text().strip()
        target_channels = []
        if channels_text:
            try:
                target_channels = [int(c.strip()) for c in channels_text.split(",") if c.strip()]
            except ValueError:
                pass  # å¿½ç•¥æ— æ•ˆçš„é¢‘é“ID

        return {
            'keywords': [k.strip() for k in self.keywords_input.text().split(",") if k.strip()],
            'reply': self.reply_input.toPlainText().strip(),
            'match_type': match_type_map[self.match_type_combo.currentIndex()],
            'target_channels': target_channels,
            'delay_min': self.delay_min_spin.value(),
            'delay_max': self.delay_max_spin.value(),
            'is_active': self.active_checkbox.isChecked(),
            'ignore_replies': self.ignore_replies_checkbox.isChecked(),
            'ignore_mentions': self.ignore_mentions_checkbox.isChecked(),
            'case_sensitive': not self.case_sensitive_checkbox.isChecked(),        }


class WorkerThread(QThread):
    """å·¥ä½œçº¿ç¨‹ï¼Œç”¨äºè¿è¡Œå¼‚æ­¥Discordå®¢æˆ·ç«¯"""
    status_updated = Signal(dict)
    error_occurred = Signal(str)
    log_message = Signal(str)

    def __init__(self, discord_manager: DiscordManager):
        super().__init__()
        self.discord_manager = discord_manager
        self.running = False

    def run(self):
        """è¿è¡Œå¼‚æ­¥äº‹ä»¶å¾ªç¯"""
        try:
            # åˆ›å»ºä¸€ä¸ªæ–°çš„äº‹ä»¶å¾ªç¯ç”¨äºæ­¤çº¿ç¨‹
            if sys.platform == 'win32':
                asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

            asyncio.run(self._run_clients())
        except Exception as e:
            self.error_occurred.emit(str(e))

    async def _run_clients(self):
        """å¯åŠ¨å®¢æˆ·ç«¯å¹¶å®šæœŸæ›´æ–°çŠ¶æ€"""
        try:
            self.log_message.emit("å¼€å§‹å¯åŠ¨Discordå®¢æˆ·ç«¯...")
            await self.discord_manager.start_all_clients()
            self.running = True

            # ç­‰å¾…æ‰€æœ‰å®¢æˆ·ç«¯å¯åŠ¨å®Œæˆ
            total_clients = len([acc for acc in self.discord_manager.accounts if acc.is_active and acc.is_valid])

            if total_clients > 0:
                # ç®€å•çš„ç­‰å¾…ç­–ç•¥ï¼šå®šæœŸæ£€æŸ¥å®¢æˆ·ç«¯çŠ¶æ€
                max_wait_time = 15  # æœ€å¤šç­‰å¾…15ç§’
                waited_time = 0

                while waited_time < max_wait_time:
                    await asyncio.sleep(1)
                    waited_time += 1

                    # æ£€æŸ¥æœ‰å¤šå°‘å®¢æˆ·ç«¯å·²ç»å¯åŠ¨
                    running_count = len([c for c in self.discord_manager.clients if c.is_running])

                    if running_count == total_clients:
                        # æ‰€æœ‰å®¢æˆ·ç«¯éƒ½å¯åŠ¨äº†
                        break
                    elif running_count > 0 and waited_time >= 3:
                        # è‡³å°‘æœ‰ä¸€ä¸ªå®¢æˆ·ç«¯å¯åŠ¨ï¼Œä¸”å·²ç»ç­‰å¾…äº†3ç§’
                        self.log_message.emit(f"ğŸ“Š {running_count}/{total_clients} ä¸ªå®¢æˆ·ç«¯å·²è¿æ¥...")
                        break

                if waited_time >= max_wait_time:
                    self.log_message.emit("âš ï¸ å®¢æˆ·ç«¯è¿æ¥è¶…æ—¶ï¼Œä½†å°†ç»§ç»­è¿è¡Œ")

            # ç°åœ¨æ£€æŸ¥æœ€ç»ˆçŠ¶æ€
            status = self.discord_manager.get_status()
            self.status_updated.emit(status)

            running_count = len([acc for acc in status["accounts"] if acc["is_running"]])
            total_count = len(status["accounts"])

            if running_count > 0:
                self.log_message.emit(f"âœ… Discordå®¢æˆ·ç«¯å¯åŠ¨å®Œæˆ - {running_count}/{total_count} ä¸ªå®¢æˆ·ç«¯è¿è¡Œä¸­")
            else:
                self.log_message.emit("âŒ Discordå®¢æˆ·ç«¯å¯åŠ¨å¤±è´¥ - æ²¡æœ‰å®¢æˆ·ç«¯æˆåŠŸè¿æ¥")

            while self.running:
                try:
                    await asyncio.sleep(5)  # æ¯5ç§’æ›´æ–°ä¸€æ¬¡çŠ¶æ€ï¼Œä¸UIå®šæ—¶å™¨åŒæ­¥
                    if self.running:  # å†æ¬¡æ£€æŸ¥æ˜¯å¦è¿˜åœ¨è¿è¡Œ
                        status = self.discord_manager.get_status()
                        self.status_updated.emit(status)
                except asyncio.CancelledError:
                    # ä»»åŠ¡è¢«å–æ¶ˆï¼Œæ­£å¸¸é€€å‡º
                    break
                except Exception as e:
                    error_msg = f"çŠ¶æ€æ›´æ–°å‡ºé”™: {e}"
                    self.log_message.emit(error_msg)
                    # å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯ï¼Œç»§ç»­è¿è¡Œ
                    if "SSL" in str(e) or "Connection" in str(e):
                        self.log_message.emit("æ£€æµ‹åˆ°ç½‘ç»œè¿æ¥é—®é¢˜ï¼Œç»§ç»­ç›‘æ§...")
                    await asyncio.sleep(5)

        except asyncio.CancelledError:
            # ä»»åŠ¡è¢«å–æ¶ˆï¼Œæ­£å¸¸åœæ­¢
            self.log_message.emit("æ¥æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢å®¢æˆ·ç«¯...")
        except Exception as e:
            error_msg = f"Discordå®¢æˆ·ç«¯è¿è¡Œé”™è¯¯: {str(e)}"
            self.log_message.emit(error_msg)

            # ç‰¹æ®Šå¤„ç†SSLé”™è¯¯
            if "SSL" in str(e) or "APPLICATION_DATA_AFTER_CLOSE_NOTIFY" in str(e):
                self.log_message.emit("âš ï¸ æ£€æµ‹åˆ°SSLè¿æ¥é”™è¯¯ï¼Œè¿™é€šå¸¸æ˜¯ç½‘ç»œé—®é¢˜ï¼Œä¸å½±å“åŠŸèƒ½")
            else:
                import traceback
                detailed_error = f"è¯¦ç»†é”™è¯¯: {traceback.format_exc()}"
                self.log_message.emit(detailed_error)
                self.error_occurred.emit(error_msg)

        finally:
            # ç¡®ä¿åœ¨é€€å‡ºæ—¶åœæ­¢æ‰€æœ‰å®¢æˆ·ç«¯
            try:
                self.log_message.emit("æ­£åœ¨æ¸…ç†èµ„æº...")
                await self.discord_manager.stop_all_clients()
                self.log_message.emit("Discordå®¢æˆ·ç«¯å·²å®Œå…¨åœæ­¢")
            except Exception as cleanup_error:
                self.log_message.emit(f"æ¸…ç†èµ„æºæ—¶å‡ºé”™: {cleanup_error}")

    def stop(self):
        """åœæ­¢å·¥ä½œçº¿ç¨‹"""
        print("æ­£åœ¨åœæ­¢Discordå·¥ä½œçº¿ç¨‹...")
        self.running = False

        # è¿™ç§æ–¹å¼å¹¶ä¸æ€»æ˜¯èƒ½ä¼˜é›…åœ°åœæ­¢ asyncio.run()ï¼Œä½†åœ¨ WorkerThread æ¨¡å‹ä¸­ï¼Œ
        # æˆ‘ä»¬ä¾é  _run_clients ä¸­çš„ loop check å’Œ sleep æ¥é€€å‡º
        # åœ¨GUIçº¿ç¨‹ä¸­æˆ‘ä»¬åªèƒ½ç­‰å¾… QThread ç»“æŸ
        pass



class MainWindow(QMainWindow):
    # å®šä¹‰ä¿¡å·
    log_signal = Signal(str, str)  # message, level

    def __init__(self):
        super().__init__()
        self.discord_manager = DiscordManager(log_callback=self.add_log_thread_safe)
        self.config_manager = ConfigManager()
        self.worker_thread = None

        self.init_ui()
        self.load_config()

        # è¿æ¥æ—¥å¿—ä¿¡å·
        self.log_signal.connect(self.add_log)

    def init_ui(self):
        """åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢"""
        self.setWindowTitle("Discord è‡ªåŠ¨å›å¤å·¥å…·")
        self.setGeometry(100, 100, 1200, 800)

        # åˆ›å»ºä¸­å¤®éƒ¨ä»¶
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # åˆ›å»ºä¸»å¸ƒå±€
        main_layout = QVBoxLayout(central_widget)

        # åˆ›å»ºæ ‡ç­¾é¡µ
        self.tab_widget = QTabWidget()
        main_layout.addWidget(self.tab_widget)

        # è´¦å·ç®¡ç†æ ‡ç­¾é¡µ
        self.create_accounts_tab()

        # è§„åˆ™ç®¡ç†æ ‡ç­¾é¡µ
        self.create_rules_tab()

        # çŠ¶æ€ç›‘æ§æ ‡ç­¾é¡µ
        self.create_status_tab()

        # åº•éƒ¨æ§åˆ¶æ 
        self.create_control_bar(main_layout)

        # è®¾ç½®æ ·å¼
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f0f0f0;
            }
            QTabWidget::pane {
                border: 1px solid #cccccc;
                background-color: white;
            }
            QTabBar::tab {
                background-color: #e0e0e0;
                padding: 8px 16px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: white;
                font-weight: bold;
            }
            QPushButton {
                padding: 8px 16px;
                background-color: #0078d4;
                color: white;
                border: none;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #106ebe;
            }
            QPushButton:pressed {
                background-color: #005a9e;
            }
            QPushButton#start_button {
                background-color: #107c10;
            }
            QPushButton#start_button:hover {
                background-color: #0b5a0b;
            }
            QPushButton#stop_button {
                background-color: #d13438;
            }
            QPushButton#stop_button:pressed {
                background-color: #a12629;
            }
        """)

    def create_accounts_tab(self):
        """åˆ›å»ºè´¦å·ç®¡ç†æ ‡ç­¾é¡µ"""
        accounts_widget = QWidget()
        layout = QVBoxLayout(accounts_widget)

        # æ ‡é¢˜å’Œæ“ä½œæŒ‰é’®
        header_layout = QHBoxLayout()
        header_layout.addWidget(QLabel("Discord è´¦å·ç®¡ç†"))

        header_layout.addStretch()

        revalidate_all_btn = QPushButton("é‡æ–°éªŒè¯æ‰€æœ‰")
        revalidate_all_btn.clicked.connect(self.revalidate_all_accounts)
        header_layout.addWidget(revalidate_all_btn)

        add_account_btn = QPushButton("æ·»åŠ è´¦å·")
        add_account_btn.clicked.connect(self.add_account)
        header_layout.addWidget(add_account_btn)

        layout.addLayout(header_layout)

        # è´¦å·è¡¨æ ¼
        self.accounts_table = QTableWidget()
        self.accounts_table.setColumnCount(4)
        self.accounts_table.setHorizontalHeaderLabels(["ç”¨æˆ·å", "TokençŠ¶æ€", "åº”ç”¨è§„åˆ™", "æ“ä½œ"])
        self.accounts_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.accounts_table.setAlternatingRowColors(True)
        self.accounts_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.accounts_table.setSelectionMode(QTableWidget.SelectionMode.MultiSelection)
        self.accounts_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.accounts_table.customContextMenuRequested.connect(self.show_accounts_context_menu)
        layout.addWidget(self.accounts_table)

        # ç»Ÿè®¡ä¿¡æ¯
        self.accounts_stats_label = QLabel("æ€»è´¦å·æ•°: 0 | å¯ç”¨è´¦å·æ•°: 0")
        layout.addWidget(self.accounts_stats_label)

        self.tab_widget.addTab(accounts_widget, "è´¦å·ç®¡ç†")

    def create_rules_tab(self):
        """åˆ›å»ºè§„åˆ™ç®¡ç†æ ‡ç­¾é¡µ"""
        rules_widget = QWidget()
        layout = QVBoxLayout(rules_widget)

        # æ ‡é¢˜å’Œæ·»åŠ æŒ‰é’®
        header_layout = QHBoxLayout()
        header_layout.addWidget(QLabel("è‡ªåŠ¨å›å¤è§„åˆ™ç®¡ç†"))

        # æœç´¢æ¡†
        self.rule_search_input = QLineEdit()
        self.rule_search_input.setPlaceholderText("æœç´¢å…³é”®è¯...")
        self.rule_search_input.textChanged.connect(self.filter_rules)
        header_layout.addWidget(self.rule_search_input)

        header_layout.addStretch()

        add_rule_btn = QPushButton("æ·»åŠ è§„åˆ™")
        add_rule_btn.clicked.connect(self.add_rule)
        header_layout.addWidget(add_rule_btn)

        layout.addLayout(header_layout)

        # è§„åˆ™è¡¨æ ¼
        self.rules_table = QTableWidget()
        self.rules_table.setColumnCount(8)
        self.rules_table.setHorizontalHeaderLabels(["å…³é”®è¯", "å›å¤å†…å®¹", "åŒ¹é…ç±»å‹", "é¢‘é“", "å»¶è¿Ÿ", "å¿½ç•¥å›å¤", "å¿½ç•¥@", "æ“ä½œ"])
        self.rules_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.rules_table.setAlternatingRowColors(True)
        self.rules_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.rules_table.setSelectionMode(QTableWidget.SelectionMode.MultiSelection)
        self.rules_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.rules_table.customContextMenuRequested.connect(self.show_rules_context_menu)
        layout.addWidget(self.rules_table)

        # ç»Ÿè®¡ä¿¡æ¯
        self.rules_stats_label = QLabel("æ€»è§„åˆ™æ•°: 0 | å¯ç”¨è§„åˆ™æ•°: 0")
        layout.addWidget(self.rules_stats_label)

        self.tab_widget.addTab(rules_widget, "è§„åˆ™ç®¡ç†")

    def create_status_tab(self):
        """åˆ›å»ºçŠ¶æ€ç›‘æ§æ ‡ç­¾é¡µ"""
        status_widget = QWidget()
        layout = QVBoxLayout(status_widget)

        # è´¦å·çŠ¶æ€è¡¨æ ¼
        accounts_group = QGroupBox("è´¦å·çŠ¶æ€")
        accounts_layout = QVBoxLayout(accounts_group)

        self.status_accounts_table = QTableWidget()
        self.status_accounts_table.setColumnCount(3)
        self.status_accounts_table.setHorizontalHeaderLabels(["åˆ«å", "çŠ¶æ€", "è¿è¡ŒçŠ¶æ€"])
        self.status_accounts_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        accounts_layout.addWidget(self.status_accounts_table)

        layout.addWidget(accounts_group)

        # è§„åˆ™ç»Ÿè®¡
        rules_group = QGroupBox("è§„åˆ™ç»Ÿè®¡")
        rules_layout = QVBoxLayout(rules_group)

        self.rules_stats_label = QLabel("æ€»è§„åˆ™æ•°: 0 | æ¿€æ´»è§„åˆ™æ•°: 0")
        rules_layout.addWidget(self.rules_stats_label)

        layout.addWidget(rules_group)

        # è½®æ¢è®¾ç½®
        rotation_group = QGroupBox("è´¦å·è½®æ¢è®¾ç½®")
        rotation_layout = QVBoxLayout(rotation_group)

        # å¯ç”¨è½®æ¢
        self.rotation_enabled_checkbox = QCheckBox("å¯ç”¨è´¦å·è½®æ¢")
        self.rotation_enabled_checkbox.setToolTip("å¯ç”¨åï¼Œå½“è´¦å·è¢«é¢‘ç‡é™åˆ¶æ—¶ä¼šè‡ªåŠ¨åˆ‡æ¢åˆ°å…¶ä»–è´¦å·å‘é€æ¶ˆæ¯")
        self.rotation_enabled_checkbox.stateChanged.connect(self.on_rotation_enabled_changed)
        rotation_layout.addWidget(self.rotation_enabled_checkbox)

        # è½®æ¢é—´éš”è®¾ç½®
        interval_layout = QHBoxLayout()
        interval_layout.addWidget(QLabel("è½®æ¢é—´éš”(åˆ†é’Ÿ):"))
        self.rotation_interval_spin = QSpinBox()
        self.rotation_interval_spin.setRange(1, 1440)  # 1åˆ†é’Ÿåˆ°24å°æ—¶
        self.rotation_interval_spin.setValue(10)  # é»˜è®¤10åˆ†é’Ÿ
        self.rotation_interval_spin.setSuffix("åˆ†é’Ÿ")
        self.rotation_interval_spin.setEnabled(False)  # é»˜è®¤ç¦ç”¨
        interval_layout.addWidget(self.rotation_interval_spin)
        interval_layout.addStretch()
        rotation_layout.addLayout(interval_layout)

        # è½®æ¢çŠ¶æ€
        self.rotation_status_label = QLabel("è½®æ¢æ¨¡å¼: æœªå¯ç”¨")
        rotation_layout.addWidget(self.rotation_status_label)

        layout.addWidget(rotation_group)

        # æ—¥å¿—æ˜¾ç¤º
        log_group = QGroupBox("è¿è¡Œæ—¥å¿—")
        log_layout = QVBoxLayout(log_group)

        # æ—¥å¿—æ§åˆ¶æŒ‰é’®
        log_controls = QHBoxLayout()
        log_controls.addWidget(QLabel("æ—¥å¿—:"))

        clear_log_btn = QPushButton("æ¸…ç©ºæ—¥å¿—")
        clear_log_btn.clicked.connect(self.clear_log)
        log_controls.addWidget(clear_log_btn)

        log_controls.addStretch()

        auto_scroll_checkbox = QCheckBox("è‡ªåŠ¨æ»šåŠ¨")
        auto_scroll_checkbox.setChecked(True)
        self.auto_scroll_log = auto_scroll_checkbox.isChecked()
        auto_scroll_checkbox.stateChanged.connect(self.toggle_auto_scroll)
        log_controls.addWidget(auto_scroll_checkbox)

        log_layout.addLayout(log_controls)

        self.log_text = QTextEdit()
        self.log_text.setMaximumHeight(200)
        self.log_text.setReadOnly(True)
        self.log_text.setFont(QFont("Consolas", 12))  # ç­‰å®½å­—ä½“ï¼Œä¾¿äºæŸ¥çœ‹
        log_layout.addWidget(self.log_text)

        layout.addWidget(log_group)

        self.tab_widget.addTab(status_widget, "çŠ¶æ€ç›‘æ§")

    def create_control_bar(self, parent_layout):
        """åˆ›å»ºåº•éƒ¨æ§åˆ¶æ """
        control_layout = QHBoxLayout()

        # å¯åŠ¨æŒ‰é’®
        self.start_button = QPushButton("å¯åŠ¨")
        self.start_button.setObjectName("start_button")
        self.start_button.clicked.connect(self.start_bot)
        control_layout.addWidget(self.start_button)

        # åœæ­¢æŒ‰é’®
        self.stop_button = QPushButton("åœæ­¢")
        self.stop_button.setObjectName("stop_button")
        self.stop_button.clicked.connect(self.stop_bot)
        self.stop_button.setEnabled(False)
        control_layout.addWidget(self.stop_button)

        # é…ç½®å¯¼å…¥å¯¼å‡º
        control_layout.addStretch()

        export_btn = QPushButton("å¯¼å‡ºé…ç½®")
        export_btn.clicked.connect(self.export_config)
        control_layout.addWidget(export_btn)

        import_btn = QPushButton("å¯¼å…¥é…ç½®")
        import_btn.clicked.connect(self.import_config)
        control_layout.addWidget(import_btn)

        parent_layout.addLayout(control_layout)

    def load_config(self):
        """åŠ è½½é…ç½®"""
        accounts, rules = self.config_manager.load_config()
        self.discord_manager.accounts = accounts
        self.discord_manager.rules = rules

        # åŠ è½½è½®æ¢è®¾ç½®ï¼ˆæš‚æ—¶ä½¿ç”¨é»˜è®¤å€¼ï¼Œåç»­å¯ä»¥æ‰©å±•é…ç½®æ–‡ä»¶ï¼‰
        # TODO: ä»é…ç½®æ–‡ä»¶åŠ è½½è½®æ¢è®¾ç½®

        self.update_accounts_list()
        self.update_rules_list()
        self.update_status()

    def save_config(self):
        """ä¿å­˜é…ç½®"""
        self.config_manager.save_config(
            self.discord_manager.accounts,
            self.discord_manager.rules
        )

    def update_accounts_list(self):
        """æ›´æ–°è´¦å·è¡¨æ ¼æ˜¾ç¤º"""
        self.accounts_table.setRowCount(len(self.discord_manager.accounts))

        for row, account in enumerate(self.discord_manager.accounts):
            # ç”¨æˆ·å
            username = account.alias  # ä½¿ç”¨aliaså±æ€§ï¼Œå®ƒä¼šè‡ªåŠ¨ç”Ÿæˆç”¨æˆ·å
            username_item = QTableWidgetItem(username)
            username_item.setData(Qt.ItemDataRole.UserRole, account.token)  # ä½¿ç”¨tokenä½œä¸ºæ ‡è¯†
            self.accounts_table.setItem(row, 0, username_item)

            # TokençŠ¶æ€
            token_type = account.user_info.get('token_type') if account.user_info and isinstance(account.user_info, dict) else None
            if account.is_valid:
                if token_type == 'bot':
                    token_status = "æœ‰æ•ˆ (Bot)"
                    bg_color = QColor(144, 238, 144)  # æµ…ç»¿è‰²
                elif token_type == 'user':
                    token_status = "æœ‰æ•ˆ (ç”¨æˆ·)"
                    bg_color = QColor(255, 255, 224)  # æµ…é»„è‰² - è­¦å‘Šè‰²
                else:
                    token_status = "æœ‰æ•ˆ"
                    bg_color = QColor(144, 238, 144)  # æµ…ç»¿è‰²
            else:
                token_status = "æ— æ•ˆ"
                bg_color = QColor(255, 182, 193)  # æµ…çº¢è‰²

            token_status_item = QTableWidgetItem(token_status)
            token_status_item.setBackground(bg_color)

            # æ·»åŠ å·¥å…·æç¤º
            if token_type == 'user':
                token_status_item.setToolTip("ç”¨æˆ·Tokenå¯ä»¥éªŒè¯ä½†æ— æ³•è¿æ¥ï¼Œè¯·ä½¿ç”¨Bot Token")
            elif token_type == 'bot':
                token_status_item.setToolTip("Bot Tokenï¼Œå®Œå…¨æ”¯æŒè¿æ¥å’Œæ¶ˆæ¯å¤„ç†")

            self.accounts_table.setItem(row, 1, token_status_item)

            # åº”ç”¨è§„åˆ™ï¼ˆæ˜¾ç¤ºå…³è”çš„è§„åˆ™æ•°é‡ï¼‰
            applied_rules = len(account.rule_ids)
            total_rules = len(self.discord_manager.rules)
            rules_text = f"{applied_rules}/{total_rules}"
            rules_item = QTableWidgetItem(rules_text)
            if applied_rules > 0:
                rules_item.setBackground(QColor(173, 216, 230))  # æµ…è“è‰²
            else:
                rules_item.setBackground(QColor(240, 240, 240))  # æµ…ç°è‰²
            rules_item.setData(Qt.ItemDataRole.UserRole, account.rule_ids)  # å­˜å‚¨è§„åˆ™IDåˆ—è¡¨
            self.accounts_table.setItem(row, 2, rules_item)

            # æ“ä½œæŒ‰é’®
            edit_btn = QPushButton("ç¼–è¾‘")
            edit_btn.clicked.connect(lambda checked, alias=account.alias: self.edit_account_by_alias(alias))

            rules_btn = QPushButton("è§„åˆ™")
            rules_btn.clicked.connect(lambda checked, token=account.token: self.edit_account_rules(token))

            validate_btn = QPushButton("éªŒè¯")
            validate_btn.clicked.connect(lambda checked, alias=account.alias: self.revalidate_account_by_alias(alias))

            delete_btn = QPushButton("åˆ é™¤")
            delete_btn.clicked.connect(lambda checked, token=account.token: self.remove_account_by_token(token))

            # åˆ›å»ºæŒ‰é’®å®¹å™¨
            button_widget = QWidget()
            button_layout = QHBoxLayout(button_widget)
            button_layout.setContentsMargins(2, 2, 2, 2)
            button_layout.addWidget(edit_btn)
            button_layout.addWidget(rules_btn)
            button_layout.addWidget(validate_btn)
            button_layout.addWidget(delete_btn)

            self.accounts_table.setCellWidget(row, 3, button_widget)

        # æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        total_accounts = len(self.discord_manager.accounts)
        active_accounts = len([acc for acc in self.discord_manager.accounts if acc.is_active])
        self.accounts_stats_label.setText(f"æ€»è´¦å·æ•°: {total_accounts} | å¯ç”¨è´¦å·æ•°: {active_accounts}")

    def update_rules_list(self):
        """æ›´æ–°è§„åˆ™è¡¨æ ¼æ˜¾ç¤º"""
        self.rules_table.setRowCount(len(self.discord_manager.rules))

        for row, rule in enumerate(self.discord_manager.rules):
            # å…³é”®è¯
            keywords_str = ", ".join(rule.keywords[:2])
            if len(rule.keywords) > 2:
                keywords_str += "..."
            keywords_item = QTableWidgetItem(keywords_str)
            keywords_item.setData(Qt.ItemDataRole.UserRole, row)
            keywords_item.setToolTip(", ".join(rule.keywords))  # æ‚¬åœæ˜¾ç¤ºæ‰€æœ‰å…³é”®è¯
            self.rules_table.setItem(row, 0, keywords_item)

            # å›å¤å†…å®¹
            reply_display = rule.reply[:30] + "..." if len(rule.reply) > 30 else rule.reply
            reply_item = QTableWidgetItem(reply_display)
            reply_item.setToolTip(rule.reply)  # æ‚¬åœæ˜¾ç¤ºå®Œæ•´å›å¤
            self.rules_table.setItem(row, 1, reply_item)

            # åŒ¹é…ç±»å‹
            match_type_name = {
                "partial": "éƒ¨åˆ†åŒ¹é…",
                "exact": "ç²¾ç¡®åŒ¹é…",
                "regex": "æ­£åˆ™è¡¨è¾¾å¼"
            }[rule.match_type.value]
            match_item = QTableWidgetItem(match_type_name)
            self.rules_table.setItem(row, 2, match_item)

            # é¢‘é“ä¿¡æ¯
            channels_info = f"{len(rule.target_channels)}ä¸ªé¢‘é“" if rule.target_channels else "å…¨éƒ¨é¢‘é“"
            channels_display = ", ".join(map(str, rule.target_channels[:2]))
            if len(rule.target_channels) > 2:
                channels_display += "..."
            channels_item = QTableWidgetItem(channels_display if rule.target_channels else "å…¨éƒ¨")
            channels_item.setToolTip(", ".join(map(str, rule.target_channels)) if rule.target_channels else "ç›‘å¬æ‰€æœ‰é¢‘é“")
            self.rules_table.setItem(row, 3, channels_item)

            # å»¶è¿Ÿ
            delay_info = f"{rule.delay_min:.1f}-{rule.delay_max:.1f}ç§’"
            delay_item = QTableWidgetItem(delay_info)
            self.rules_table.setItem(row, 4, delay_item)

            # å¿½ç•¥å›å¤
            ignore_replies_status = "æ˜¯" if getattr(rule, 'ignore_replies', False) else "å¦"
            ignore_item = QTableWidgetItem(ignore_replies_status)
            ignore_item.setData(Qt.ItemDataRole.ToolTipRole, "æ˜¯å¦å¿½ç•¥å›å¤ä»–äººçš„æ¶ˆæ¯")
            self.rules_table.setItem(row, 5, ignore_item)

            # å¿½ç•¥@
            ignore_mentions_status = "æ˜¯" if getattr(rule, 'ignore_mentions', False) else "å¦"
            mentions_item = QTableWidgetItem(ignore_mentions_status)
            mentions_item.setData(Qt.ItemDataRole.ToolTipRole, "æ˜¯å¦å¿½ç•¥åŒ…å«@ä»–äººçš„æ¶ˆæ¯")
            self.rules_table.setItem(row, 6, mentions_item)

            # æ“ä½œæŒ‰é’®
            edit_btn = QPushButton("ç¼–è¾‘")
            edit_btn.clicked.connect(lambda checked, index=row: self.edit_rule_by_index(index))

            delete_btn = QPushButton("åˆ é™¤")
            delete_btn.clicked.connect(lambda checked, index=row: self.remove_rule_by_index(index))

            # åˆ›å»ºæŒ‰é’®å®¹å™¨
            button_widget = QWidget()
            button_layout = QHBoxLayout(button_widget)
            button_layout.setContentsMargins(5, 2, 5, 2)
            button_layout.addWidget(edit_btn)
            button_layout.addWidget(delete_btn)
            button_layout.addStretch()

            self.rules_table.setCellWidget(row, 7, button_widget)

        # æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        total_rules = len(self.discord_manager.rules)
        active_rules = len([rule for rule in self.discord_manager.rules if rule.is_active])
        self.rules_stats_label.setText(f"æ€»è§„åˆ™æ•°: {total_rules} | å¯ç”¨è§„åˆ™æ•°: {active_rules}")

        # åº”ç”¨å½“å‰æœç´¢è¿‡æ»¤
        self.filter_rules()

    def filter_rules(self):
        """æ ¹æ®æœç´¢å…³é”®è¯è¿‡æ»¤è§„åˆ™æ˜¾ç¤º"""
        search_text = self.rule_search_input.text().strip().lower()

        for row in range(self.rules_table.rowCount()):
            show_row = True
            if search_text:
                # æ£€æŸ¥å…³é”®è¯åˆ—æ˜¯å¦åŒ…å«æœç´¢æ–‡æœ¬
                keywords_item = self.rules_table.item(row, 0)
                if keywords_item:
                    keywords = keywords_item.toolTip().lower() if keywords_item.toolTip() else keywords_item.text().lower()
                    if search_text not in keywords:
                        show_row = False

            self.rules_table.setRowHidden(row, not show_row)

    def update_status(self):
        """æ›´æ–°çŠ¶æ€æ˜¾ç¤º"""
        try:
            status = self.discord_manager.get_status()

            # æ›´æ–°è´¦å·è¡¨æ ¼
            account_count = len(status["accounts"])
            self.status_accounts_table.setRowCount(account_count)

            for i, acc in enumerate(status["accounts"]):
                # åªåœ¨æ•°æ®çœŸæ­£æ”¹å˜æ—¶æ‰æ›´æ–°ï¼Œé¿å…ä¸å¿…è¦çš„UIé‡ç»˜
                current_alias = self.status_accounts_table.item(i, 0)
                if not current_alias or current_alias.text() != acc["alias"]:
                    self.status_accounts_table.setItem(i, 0, QTableWidgetItem(acc["alias"]))

                current_active = self.status_accounts_table.item(i, 1)
                active_text = "å¯ç”¨" if acc["is_active"] else "ç¦ç”¨"
                if not current_active or current_active.text() != active_text:
                    self.status_accounts_table.setItem(i, 1, QTableWidgetItem(active_text))

                running_status = "è¿è¡Œä¸­" if acc["is_running"] else "æœªè¿è¡Œ"
                current_running = self.status_accounts_table.item(i, 2)
                if not current_running or current_running.text() != running_status:
                    item = QTableWidgetItem(running_status)
                    if acc["is_running"]:
                        item.setBackground(QColor(144, 238, 144))  # æµ…ç»¿è‰²
                    else:
                        item.setBackground(QColor(255, 182, 193))  # æµ…çº¢è‰²
                    self.status_accounts_table.setItem(i, 2, item)

            # æ›´æ–°è§„åˆ™ç»Ÿè®¡
            rules_text = f"æ€»è§„åˆ™æ•°: {status['rules_count']} | æ¿€æ´»è§„åˆ™æ•°: {status['active_rules']}"
            if self.rules_stats_label.text() != rules_text:
                self.rules_stats_label.setText(rules_text)

        except Exception as e:
            # é™é»˜å¤„ç†çŠ¶æ€æ›´æ–°é”™è¯¯ï¼Œé¿å…å½±å“ç”¨æˆ·ä½“éªŒ
            print(f"çŠ¶æ€æ›´æ–°é”™è¯¯: {e}")

    def show_accounts_context_menu(self, position):
        """æ˜¾ç¤ºè´¦å·å³é”®èœå•"""
        selected_rows = set()
        for item in self.accounts_table.selectedItems():
            selected_rows.add(item.row())

        menu = QMenu()

        if len(selected_rows) == 1:
            # å•ä¸ªè´¦å·çš„èœå•
            current_row = list(selected_rows)[0]
            edit_action = menu.addAction("ç¼–è¾‘è´¦å·")
            delete_action = menu.addAction("åˆ é™¤è´¦å·")
        elif len(selected_rows) > 1:
            # å¤šä¸ªè´¦å·çš„èœå•
            delete_multiple_action = menu.addAction(f"åˆ é™¤é€‰ä¸­çš„ {len(selected_rows)} ä¸ªè´¦å·")
        else:
            # æ²¡æœ‰é€‰ä¸­è´¦å·æ—¶çš„èœå•
            return

        action = menu.exec(self.accounts_table.mapToGlobal(position))

        if len(selected_rows) == 1:
            current_row = list(selected_rows)[0]
            if action == edit_action:
                token_item = self.accounts_table.item(current_row, 0)
                if token_item:
                    token = token_item.data(Qt.ItemDataRole.UserRole)
                    self.edit_account_by_alias(token)  # ä½¿ç”¨aliasæ–¹æ³•ï¼Œå› ä¸ºtokenä½œä¸ºaliaså­˜å‚¨
            elif action == delete_action:
                token_item = self.accounts_table.item(current_row, 0)
                if token_item:
                    token = token_item.data(Qt.ItemDataRole.UserRole)
                    self.remove_account_by_token(token)
        elif len(selected_rows) > 1:
            if action == delete_multiple_action:
                self.remove_multiple_accounts(list(selected_rows))

    def show_rules_context_menu(self, position):
        """æ˜¾ç¤ºè§„åˆ™å³é”®èœå•"""
        selected_rows = set()
        for item in self.rules_table.selectedItems():
            selected_rows.add(item.row())

        menu = QMenu()

        if len(selected_rows) == 1:
            # å•ä¸ªè§„åˆ™çš„èœå•
            current_row = list(selected_rows)[0]
            edit_action = menu.addAction("ç¼–è¾‘è§„åˆ™")
            delete_action = menu.addAction("åˆ é™¤è§„åˆ™")
        elif len(selected_rows) > 1:
            # å¤šä¸ªè§„åˆ™çš„èœå•
            delete_multiple_action = menu.addAction(f"åˆ é™¤é€‰ä¸­çš„ {len(selected_rows)} ä¸ªè§„åˆ™")
        else:
            # æ²¡æœ‰é€‰ä¸­è§„åˆ™æ—¶çš„èœå•
            return

        action = menu.exec(self.rules_table.mapToGlobal(position))

        if len(selected_rows) == 1:
            current_row = list(selected_rows)[0]
            if action == edit_action:
                self.edit_rule_by_index(current_row)
            elif action == delete_action:
                self.remove_rule_by_index(current_row)
        elif len(selected_rows) > 1:
            if action == delete_multiple_action:
                self.remove_multiple_rules(list(selected_rows))

    def add_account(self):
        """æ·»åŠ æ–°è´¦å·"""
        dialog = AccountDialog(self, discord_manager=self.discord_manager)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_account_data()

            if not data['token']:
                QMessageBox.warning(self, "é”™è¯¯", "Tokenä¸èƒ½ä¸ºç©º")
                return

            # æ£€æŸ¥Tokenæ˜¯å¦é‡å¤
            if any(acc.token == data['token'] for acc in self.discord_manager.accounts):
                QMessageBox.warning(self, "é”™è¯¯", "è¯¥Tokenå·²å­˜åœ¨")
                return

            # ä½¿ç”¨å¼‚æ­¥æ–¹æ³•æ·»åŠ è´¦å·
            import asyncio
            try:
                async def add_account_async():
                    success, message = await self.discord_manager.add_account_async(data['token'])
                    # è®¾ç½®æ¿€æ´»çŠ¶æ€
                    if success and data['token'] in [acc.token for acc in self.discord_manager.accounts]:
                        for acc in self.discord_manager.accounts:
                            if acc.token == data['token']:
                                acc.is_active = data['is_active']
                                break
                    return success, message

                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                success, message = loop.run_until_complete(add_account_async())

                if success:
                    self.add_log(message, "success")
                    self.update_accounts_list()
                    self.save_config()
                    QMessageBox.information(self, "æˆåŠŸ", message)
                else:
                    self.log_text.append(f"âŒ {message}")
                    QMessageBox.warning(self, "æ·»åŠ å¤±è´¥", message)

            except Exception as e:
                error_msg = f"æ·»åŠ è´¦å·æ—¶å‡ºé”™: {str(e)}"
                self.add_log(error_msg, "error")
                QMessageBox.critical(self, "é”™è¯¯", error_msg)

    def edit_account_by_alias(self, alias):
        """é€šè¿‡åˆ«åç¼–è¾‘è´¦å·"""
        account = next((acc for acc in self.discord_manager.accounts if acc.alias == alias), None)
        if not account:
            QMessageBox.warning(self, "é”™è¯¯", "è´¦å·ä¸å­˜åœ¨")
            return

        dialog = AccountDialog(self, account, discord_manager=self.discord_manager)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_account_data()

            if not data['token']:
                QMessageBox.warning(self, "é”™è¯¯", "Tokenä¸èƒ½ä¸ºç©º")
                return

            # æ£€æŸ¥Tokenæ˜¯å¦é‡å¤ï¼ˆæ’é™¤å½“å‰è´¦å·ï¼‰
            if data['token'] != alias and any(acc.token == data['token'] for acc in self.discord_manager.accounts):
                QMessageBox.warning(self, "é”™è¯¯", "è¯¥Tokenå·²å­˜åœ¨")
                return

            # æ›´æ–°è´¦å·ä¿¡æ¯
            account.token = data['token']
            account.is_active = data['is_active']
            account.is_valid = data.get('is_valid', False)
            account.user_info = data.get('user_info')

            self.add_log(f"è´¦å· '{account.alias}' æ›´æ–°æˆåŠŸ", "success")
            self.update_accounts_list()
            self.save_config()
            QMessageBox.information(self, "æˆåŠŸ", "è´¦å·ç¼–è¾‘æˆåŠŸ")

    def edit_account_rules(self, token: str):
        """ç¼–è¾‘è´¦å·åº”ç”¨çš„è§„åˆ™"""
        account = next((acc for acc in self.discord_manager.accounts if acc.token == token), None)
        if not account:
            QMessageBox.warning(self, "é”™è¯¯", "è´¦å·ä¸å­˜åœ¨")
            return

        dialog = AccountRulesDialog(self, account, self.discord_manager.rules)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_rule_ids = dialog.get_selected_rule_ids()
            account.rule_ids = selected_rule_ids
            self.add_log(f"è´¦å· '{account.alias}' è§„åˆ™é…ç½®æ›´æ–°æˆåŠŸ", "success")
            self.update_accounts_list()
            self.save_config()
            QMessageBox.information(self, "æˆåŠŸ", "è§„åˆ™é…ç½®æ›´æ–°æˆåŠŸ")

    def revalidate_all_accounts(self):
        """é‡æ–°éªŒè¯æ‰€æœ‰è´¦å·"""
        if not self.discord_manager.accounts:
            QMessageBox.information(self, "æç¤º", "æ²¡æœ‰è´¦å·éœ€è¦éªŒè¯")
            return

        self.add_log("å¼€å§‹é‡æ–°éªŒè¯æ‰€æœ‰è´¦å·çš„Token", "info")

        # åœ¨æ–°çš„äº‹ä»¶å¾ªç¯ä¸­è¿è¡Œå¼‚æ­¥éªŒè¯
        import asyncio
        try:
            async def revalidate_all():
                results = await self.discord_manager.revalidate_all_accounts()
                return results

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            results = loop.run_until_complete(revalidate_all())

            success_count = 0
            fail_count = 0

            for result in results:
                alias = result['alias']
                is_valid = result['is_valid']
                error_msg = result['error_msg']

                if is_valid:
                    user_info = result['user_info']
                    if user_info and isinstance(user_info, dict):
                        username = f"{user_info.get('name', 'Unknown')}#{user_info.get('discriminator', '0000')}"
                        self.add_log(f"è´¦å· '{alias}' éªŒè¯æˆåŠŸ - ç”¨æˆ·å: {username}", "success")
                    else:
                        self.add_log(f"è´¦å· '{alias}' éªŒè¯æˆåŠŸ", "success")
                    success_count += 1
                else:
                    self.add_log(f"è´¦å· '{alias}' éªŒè¯å¤±è´¥: {error_msg}", "error")
                    fail_count += 1

            self.add_log(f"æ‰¹é‡éªŒè¯å®Œæˆ - æˆåŠŸ: {success_count}, å¤±è´¥: {fail_count}", "info")
            self.update_accounts_list()
            self.save_config()

            QMessageBox.information(
                self, "æ‰¹é‡éªŒè¯å®Œæˆ",
                f"éªŒè¯å®Œæˆ\næˆåŠŸ: {success_count}\nå¤±è´¥: {fail_count}"
            )

        except Exception as e:
            error_msg = f"æ‰¹é‡éªŒè¯è¿‡ç¨‹ä¸­å‡ºé”™: {str(e)}"
            self.add_log(error_msg, "error")
            QMessageBox.critical(self, "éªŒè¯é”™è¯¯", error_msg)

    def revalidate_account_by_alias(self, alias):
        """é‡æ–°éªŒè¯è´¦å·Token"""
        account = next((acc for acc in self.discord_manager.accounts if acc.alias == alias), None)
        if account:
            self.add_log(f"æ­£åœ¨é‡æ–°éªŒè¯è´¦å· '{account.alias}' çš„Token", "info")
        else:
            self.add_log("è´¦å·ä¸å­˜åœ¨", "error")
            return

        # åœ¨æ–°çš„äº‹ä»¶å¾ªç¯ä¸­è¿è¡Œå¼‚æ­¥éªŒè¯
        import asyncio
        try:
            async def revalidate():
                success, message = await self.discord_manager.revalidate_account(account.token)
                return success, message

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            success, message = loop.run_until_complete(revalidate())

            if success:
                self.add_log(message, "success")
                QMessageBox.information(self, "éªŒè¯æˆåŠŸ", message)
            else:
                self.log_text.append(f"âŒ {message}")
                QMessageBox.warning(self, "éªŒè¯å¤±è´¥", message)

            self.update_accounts_list()
            self.save_config()

        except Exception as e:
            error_msg = f"éªŒè¯è¿‡ç¨‹ä¸­å‡ºé”™: {str(e)}"
            self.add_log(error_msg, "error")
            QMessageBox.critical(self, "éªŒè¯é”™è¯¯", error_msg)

    def remove_account_by_token(self, token):
        """é€šè¿‡tokenåˆ é™¤è´¦å·"""
        account = next((acc for acc in self.discord_manager.accounts if acc.token == token), None)
        if not account:
            QMessageBox.warning(self, "é”™è¯¯", "è´¦å·ä¸å­˜åœ¨")
            return

        reply = QMessageBox.question(
            self, "ç¡®è®¤åˆ é™¤",
            f"ç¡®å®šè¦åˆ é™¤è´¦å· '{account.alias}' å—ï¼Ÿ",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.discord_manager.remove_account(token)
            self.add_log(f"è´¦å· '{account.alias}' å·²åˆ é™¤", "info")
            self.update_accounts_list()
            self.save_config()

    def remove_account_by_alias(self, alias):
        """é€šè¿‡åˆ«ååˆ é™¤è´¦å·"""
        reply = QMessageBox.question(
            self, "ç¡®è®¤åˆ é™¤",
            f"ç¡®å®šè¦åˆ é™¤è´¦å· '{alias}' å—ï¼Ÿ",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.discord_manager.remove_account(alias)
            self.update_accounts_list()
            self.save_config()

    def remove_multiple_accounts(self, indices):
        """æ‰¹é‡åˆ é™¤å¤šä¸ªè´¦å·"""
        indices.sort(reverse=True)  # ä»å¤§åˆ°å°æ’åºï¼Œé¿å…åˆ é™¤æ—¶ç´¢å¼•å˜åŒ–

        reply = QMessageBox.question(
            self, "ç¡®è®¤æ‰¹é‡åˆ é™¤",
            f"ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ {len(indices)} ä¸ªè´¦å·å—ï¼Ÿ\næ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            deleted_count = 0
            for index in indices:
                try:
                    # è·å–è´¦å·ä¿¡æ¯ç”¨äºæ—¥å¿—
                    if index < len(self.discord_manager.accounts):
                        account = self.discord_manager.accounts[index]
                        account_name = account.alias
                        self.discord_manager.remove_account(account.token)
                        deleted_count += 1
                        self.add_log(f"è´¦å· '{account_name}' å·²åˆ é™¤", "info")
                except (IndexError, ValueError) as e:
                    # è´¦å·å¯èƒ½å·²ç»è¢«åˆ é™¤ï¼Œè·³è¿‡
                    continue

            self.update_accounts_list()
            self.save_config()
            self.add_log(f"æˆåŠŸåˆ é™¤ {deleted_count} ä¸ªè´¦å·", "success")


    def add_rule(self):
        """æ·»åŠ æ–°è§„åˆ™"""
        dialog = RuleDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_rule_data()

            if not data['keywords'] or not data['reply']:
                QMessageBox.warning(self, "é”™è¯¯", "å…³é”®è¯å’Œå›å¤å†…å®¹ä¸èƒ½ä¸ºç©º")
                return

            self.discord_manager.add_rule(
                data['keywords'],
                data['reply'],
                MatchType(data['match_type']),
                data['target_channels'],
                data['delay_min'],
                data['delay_max'],
                data.get('ignore_replies', False),
                data.get('ignore_mentions', False)
            )

            # è®¾ç½®æ¿€æ´»çŠ¶æ€
            if self.discord_manager.rules:
                self.discord_manager.rules[-1].is_active = data['is_active']

            self.update_rules_list()
            self.save_config()
            QMessageBox.information(self, "æˆåŠŸ", "è§„åˆ™æ·»åŠ æˆåŠŸ")

    def edit_rule_by_index(self, index):
        """é€šè¿‡ç´¢å¼•ç¼–è¾‘è§„åˆ™"""
        if 0 <= index < len(self.discord_manager.rules):
            rule = self.discord_manager.rules[index]
            dialog = RuleDialog(self, rule)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                data = dialog.get_rule_data()

                if not data['keywords'] or not data['reply']:
                    QMessageBox.warning(self, "é”™è¯¯", "å…³é”®è¯å’Œå›å¤å†…å®¹ä¸èƒ½ä¸ºç©º")
                    return

                self.discord_manager.update_rule(
                    index,
                    keywords=data['keywords'],
                    reply=data['reply'],
                    match_type=MatchType(data['match_type']),
                    target_channels=data['target_channels'],
                    delay_min=data['delay_min'],
                    delay_max=data['delay_max'],
                    is_active=data['is_active'],
                    ignore_replies=data.get('ignore_replies', False),
                    ignore_mentions=data.get('ignore_mentions', False),
                    case_sensitive=data.get('case_sensitive', False)
                )

                self.update_rules_list()
                self.save_config()
                QMessageBox.information(self, "æˆåŠŸ", "è§„åˆ™ç¼–è¾‘æˆåŠŸ")

    def remove_rule_by_index(self, index):
        """é€šè¿‡ç´¢å¼•åˆ é™¤è§„åˆ™"""
        reply = QMessageBox.question(
            self, "ç¡®è®¤åˆ é™¤",
            f"ç¡®å®šè¦åˆ é™¤è§„åˆ™ {index+1} å—ï¼Ÿ",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.discord_manager.remove_rule(index)
            self.update_rules_list()
            self.save_config()

    def remove_multiple_rules(self, indices):
        """æ‰¹é‡åˆ é™¤å¤šä¸ªè§„åˆ™"""
        indices.sort(reverse=True)  # ä»å¤§åˆ°å°æ’åºï¼Œé¿å…åˆ é™¤æ—¶ç´¢å¼•å˜åŒ–

        reply = QMessageBox.question(
            self, "ç¡®è®¤æ‰¹é‡åˆ é™¤",
            f"ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ {len(indices)} ä¸ªè§„åˆ™å—ï¼Ÿ\næ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            deleted_count = 0
            for index in indices:
                try:
                    self.discord_manager.remove_rule(index)
                    deleted_count += 1
                except IndexError:
                    # è§„åˆ™å¯èƒ½å·²ç»è¢«åˆ é™¤ï¼Œè·³è¿‡
                    continue

            self.update_rules_list()
            self.save_config()
            self.add_log(f"æˆåŠŸåˆ é™¤ {deleted_count} ä¸ªè§„åˆ™", "success")




    def start_bot(self):
        """å¯åŠ¨æœºå™¨äºº"""
        self.add_log("ğŸ”„ æ­£åœ¨æ£€æŸ¥å¯åŠ¨æ¡ä»¶...", "info")

        if not self.discord_manager.accounts:
            self.add_log("âŒ å¯åŠ¨å¤±è´¥ï¼šè¯·å…ˆæ·»åŠ è‡³å°‘ä¸€ä¸ªè´¦å·", "error")
            QMessageBox.warning(self, "é”™è¯¯", "è¯·å…ˆæ·»åŠ è‡³å°‘ä¸€ä¸ªè´¦å·")
            return

        if not self.discord_manager.rules:
            self.add_log("âŒ å¯åŠ¨å¤±è´¥ï¼šè¯·å…ˆæ·»åŠ è‡³å°‘ä¸€ä¸ªè§„åˆ™", "error")
            QMessageBox.warning(self, "é”™è¯¯", "è¯·å…ˆæ·»åŠ è‡³å°‘ä¸€ä¸ªè§„åˆ™")
            return

        # æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„è´¦å·
        valid_accounts = [acc for acc in self.discord_manager.accounts if acc.is_active and acc.is_valid]
        if not valid_accounts:
            self.add_log("âŒ å¯åŠ¨å¤±è´¥ï¼šæ²¡æœ‰æœ‰æ•ˆçš„è´¦å·ï¼ˆè¯·å…ˆéªŒè¯Tokenï¼‰", "error")
            QMessageBox.warning(self, "é”™è¯¯", "æ²¡æœ‰æœ‰æ•ˆçš„è´¦å·ï¼Œè¯·å…ˆéªŒè¯Token")
            return

        try:
            self.add_log("ğŸš€ æ­£åœ¨å¯åŠ¨Discordæœºå™¨äºº...", "info")

            self.worker_thread = WorkerThread(self.discord_manager)
            self.worker_thread.status_updated.connect(self.update_status)
            self.worker_thread.error_occurred.connect(self.on_error)
            self.worker_thread.log_message.connect(self.add_log)
            self.worker_thread.start()

            self.start_button.setEnabled(False)
            self.stop_button.setEnabled(True)

            self.add_log("âœ… æœºå™¨äººå¯åŠ¨å‘½ä»¤å·²å‘é€ï¼Œæ­£åœ¨è¿æ¥DiscordæœåŠ¡å™¨...", "success")

        except Exception as e:
            error_msg = f"å¯åŠ¨å¤±è´¥: {str(e)}"
            self.add_log(f"âŒ {error_msg}", "error")
            QMessageBox.critical(self, "é”™è¯¯", error_msg)

    def stop_bot(self):
        """åœæ­¢æœºå™¨äºº"""
        if self.worker_thread:
            self.add_log("æ­£åœ¨åœæ­¢æœºå™¨äºº...", "info")

            # è®¾ç½®åœæ­¢æ ‡å¿—
            self.worker_thread.running = False

            # ç­‰å¾…çº¿ç¨‹å®Œæˆï¼Œæœ€å¤šç­‰å¾…12ç§’ï¼ˆå¢åŠ ç­‰å¾…æ—¶é—´ï¼‰
            if self.worker_thread.wait(12000):  # å¢åŠ ç­‰å¾…æ—¶é—´åˆ°12ç§’
                self.add_log("æœºå™¨äººåœæ­¢å®Œæˆ", "success")
            else:
                self.add_log("æœºå™¨äººåœæ­¢è¶…æ—¶ï¼Œä½†åå°æ¸…ç†å°†ç»§ç»­è¿›è¡Œ", "warning")

            # æ¸…ç†çº¿ç¨‹
            self.worker_thread = None

            self.start_button.setEnabled(True)
            self.stop_button.setEnabled(False)

            # å¼ºåˆ¶æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            self.update_status()

            # æ·»åŠ æœ€ç»ˆæ—¥å¿—
            self.add_log("æœºå™¨äººå·²åœæ­¢", "info")

    def add_log(self, message, level="info"):
        """æ·»åŠ æ—¥å¿—"""
        import datetime
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")

        # æ ¹æ®çº§åˆ«è®¾ç½®é¢œè‰²å’Œå‰ç¼€
        if level == "error":
            colored_msg = f'<span style="color: red;">[{timestamp}] âŒ {message}</span>'
        elif level == "warning":
            colored_msg = f'<span style="color: orange;">[{timestamp}] âš ï¸ {message}</span>'
        elif level == "success":
            colored_msg = f'<span style="color: green;">[{timestamp}] âœ… {message}</span>'
        elif level == "info":
            colored_msg = f'<span style="color: blue;">[{timestamp}] â„¹ï¸ {message}</span>'
        else:
            colored_msg = f'[{timestamp}] {message}'

        # æ·»åŠ åˆ°æ—¥å¿—æ–‡æœ¬æ¡†ï¼Œå¢åŠ è¡Œè·
        current_text = self.log_text.toHtml()
        if current_text:
            new_text = current_text + '<div style="margin: 2px 0;">' + colored_msg + '</div>'
        else:
            new_text = '<div style="margin: 2px 0;">' + colored_msg + '</div>'

        self.log_text.setHtml(new_text)

        # è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
        if self.auto_scroll_log:
            cursor = self.log_text.textCursor()
            cursor.movePosition(cursor.MoveOperation.End)
            self.log_text.setTextCursor(cursor)

    def add_log_thread_safe(self, message, level="info"):
        """çº¿ç¨‹å®‰å…¨çš„æ—¥å¿—æ·»åŠ """
        self.log_signal.emit(message, level)

    def clear_log(self):
        """æ¸…ç©ºæ—¥å¿—"""
        self.log_text.clear()
        self.add_log("æ—¥å¿—å·²æ¸…ç©º", "info")

    def toggle_auto_scroll(self, state):
        """åˆ‡æ¢è‡ªåŠ¨æ»šåŠ¨"""
        self.auto_scroll_log = state == 2  # 2è¡¨ç¤ºé€‰ä¸­çŠ¶æ€

    def on_rotation_enabled_changed(self, state):
        """è½®æ¢å¯ç”¨çŠ¶æ€æ”¹å˜"""
        enabled = state == 2  # 2è¡¨ç¤ºé€‰ä¸­çŠ¶æ€
        self.rotation_interval_spin.setEnabled(enabled)

        # æ›´æ–°DiscordManagerè®¾ç½®
        self.discord_manager.rotation_enabled = enabled
        if enabled:
            self.discord_manager.rotation_interval = self.rotation_interval_spin.value() * 60  # è½¬æ¢ä¸ºç§’
            self.rotation_status_label.setText(f"è½®æ¢æ¨¡å¼: å·²å¯ç”¨ (é—´éš”{self.rotation_interval_spin.value()}åˆ†é’Ÿ)")
        else:
            self.rotation_status_label.setText("è½®æ¢æ¨¡å¼: æœªå¯ç”¨")

        # ä¿å­˜é…ç½®
        self.save_config()

        if self.log_callback:
            status = "å¯ç”¨" if enabled else "ç¦ç”¨"
            self.log_callback(f"è´¦å·è½®æ¢æ¨¡å¼å·²{status}")

    def on_error(self, error_msg):
        """é”™è¯¯å¤„ç†"""
        QMessageBox.critical(self, "é”™è¯¯", f"è¿è¡Œæ—¶é”™è¯¯: {error_msg}")
        self.add_log(f"è¿è¡Œæ—¶é”™è¯¯: {error_msg}", "error")

    def export_config(self):
        """å¯¼å‡ºé…ç½®"""
        filename, _ = QFileDialog.getSaveFileName(
            self, "å¯¼å‡ºé…ç½®", "", "JSON æ–‡ä»¶ (*.json)"
        )
        if filename:
            if self.config_manager.export_config(
                filename, self.discord_manager.accounts, self.discord_manager.rules
            ):
                QMessageBox.information(self, "æˆåŠŸ", "é…ç½®å¯¼å‡ºæˆåŠŸ")
            else:
                QMessageBox.warning(self, "é”™è¯¯", "é…ç½®å¯¼å‡ºå¤±è´¥")

    def import_config(self):
        """å¯¼å…¥é…ç½®"""
        filename, _ = QFileDialog.getOpenFileName(
            self, "å¯¼å…¥é…ç½®", "", "JSON æ–‡ä»¶ (*.json)"
        )
        if filename:
            accounts, rules = self.config_manager.import_config(filename)
            if accounts or rules:
                self.discord_manager.accounts = accounts
                self.discord_manager.rules = rules
                self.update_accounts_list()
                self.update_rules_list()
                self.save_config()
                QMessageBox.information(self, "æˆåŠŸ", "é…ç½®å¯¼å…¥æˆåŠŸ")
            else:
                QMessageBox.warning(self, "é”™è¯¯", "é…ç½®å¯¼å…¥å¤±è´¥")


class AccountRulesDialog(QDialog):
    """è´¦å·è§„åˆ™é…ç½®å¯¹è¯æ¡†"""

    def __init__(self, parent=None, account=None, rules=None):
        super().__init__(parent)
        self.account = account
        self.rules = rules or []
        self.checkboxes = []
        self.init_ui()

    def init_ui(self):
        """åˆå§‹åŒ–ç•Œé¢"""
        self.setWindowTitle(f"é…ç½®è´¦å·è§„åˆ™ - {self.account.alias}")
        self.setModal(True)
        self.resize(500, 400)

        layout = QVBoxLayout(self)

        # æ ‡é¢˜
        title_label = QLabel(f"é€‰æ‹©è´¦å· '{self.account.alias}' è¦åº”ç”¨çš„è§„åˆ™ï¼š")
        title_label.setStyleSheet("font-weight: bold; font-size: 12px;")
        layout.addWidget(title_label)

        # è§„åˆ™é€‰æ‹©åŒºåŸŸ
        scroll_area = QScrollArea()
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout(scroll_widget)

        self.checkboxes = []
        for rule in self.rules:
            checkbox = QCheckBox(f"[{rule.id}] {rule.keywords[0] if rule.keywords else 'æ— å…³é”®è¯'} -> {rule.reply[:30]}{'...' if len(rule.reply) > 30 else ''}")
            checkbox.setChecked(rule.id in self.account.rule_ids)
            checkbox.setToolTip(f"å…³é”®è¯: {', '.join(rule.keywords)}\nå›å¤: {rule.reply}")
            self.checkboxes.append((rule.id, checkbox))
            scroll_layout.addWidget(checkbox)

        if not self.rules:
            no_rules_label = QLabel("æš‚æ— å¯ç”¨è§„åˆ™ï¼Œè¯·å…ˆæ·»åŠ è§„åˆ™")
            no_rules_label.setStyleSheet("color: gray; font-style: italic;")
            scroll_layout.addWidget(no_rules_label)

        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_widget)
        scroll_area.setWidgetResizable(True)
        layout.addWidget(scroll_area)

        # ç»Ÿè®¡ä¿¡æ¯
        stats_label = QLabel()
        self.update_stats_label(stats_label)
        layout.addWidget(stats_label)

        # è¿æ¥ä¿¡å·
        for rule_id, checkbox in self.checkboxes:
            checkbox.stateChanged.connect(lambda: self.update_stats_label(stats_label))

        # æŒ‰é’®
        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()

        select_all_btn = QPushButton("å…¨é€‰")
        select_all_btn.clicked.connect(self.select_all_rules)
        buttons_layout.addWidget(select_all_btn)

        clear_all_btn = QPushButton("æ¸…ç©º")
        clear_all_btn.clicked.connect(self.clear_all_rules)
        buttons_layout.addWidget(clear_all_btn)

        buttons_layout.addStretch()

        cancel_btn = QPushButton("å–æ¶ˆ")
        cancel_btn.clicked.connect(self.reject)
        buttons_layout.addWidget(cancel_btn)

        ok_btn = QPushButton("ç¡®å®š")
        ok_btn.clicked.connect(self.accept)
        ok_btn.setDefault(True)
        buttons_layout.addWidget(ok_btn)

        layout.addLayout(buttons_layout)

    def update_stats_label(self, label):
        """æ›´æ–°ç»Ÿè®¡æ ‡ç­¾"""
        selected_count = sum(1 for _, checkbox in self.checkboxes if checkbox.isChecked())
        total_count = len(self.checkboxes)
        label.setText(f"å·²é€‰æ‹© {selected_count}/{total_count} ä¸ªè§„åˆ™")

    def select_all_rules(self):
        """é€‰æ‹©æ‰€æœ‰è§„åˆ™"""
        for _, checkbox in self.checkboxes:
            checkbox.setChecked(True)

    def clear_all_rules(self):
        """æ¸…ç©ºæ‰€æœ‰é€‰æ‹©"""
        for _, checkbox in self.checkboxes:
            checkbox.setChecked(False)

    def get_selected_rule_ids(self):
        """è·å–é€‰ä¸­çš„è§„åˆ™IDåˆ—è¡¨"""
        return [rule_id for rule_id, checkbox in self.checkboxes if checkbox.isChecked()]


def main():
    """ä¸»å‡½æ•°"""
    app = QApplication(sys.argv)
    app.setStyle('Fusion')  # ä½¿ç”¨æ›´ç°ä»£çš„æ ·å¼

    # è®¾ç½®åº”ç”¨ç¨‹åºå±æ€§ï¼Œç¡®ä¿åœ¨macOSä¸Šæ­£ç¡®æ˜¾ç¤º
    app.setApplicationName("Discord Auto Reply")
    app.setApplicationVersion("1.0.0")
    app.setOrganizationName("DiscordAutoReply")

    window = MainWindow()
    window.show()
    window.raise_()  # ç¡®ä¿çª—å£åœ¨å‰å°æ˜¾ç¤º
    window.activateWindow()  # æ¿€æ´»çª—å£

    # åˆ›å»ºå®šæ—¶å™¨å®šæœŸæ›´æ–°çŠ¶æ€
    timer = QTimer()
    timer.timeout.connect(window.update_status)
    timer.start(5000)  # æ¯5ç§’æ›´æ–°ä¸€æ¬¡

    # è¿è¡ŒQtåº”ç”¨ç¨‹åºäº‹ä»¶å¾ªç¯
    sys.exit(app.exec())


if __name__ == "__main__":
    asyncio.run(main())
-e 

